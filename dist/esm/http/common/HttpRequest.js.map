{"version":3,"file":"HttpRequest.js","sources":["../../../../src/http/common/HttpRequest.ts"],"sourcesContent":["import { HttpConfig } from \"./HttpConfig\";\nimport { Interceptor } from \"./Interceptor\";\nimport type { HttpConfigOptions, RequestConfig } from \"@/http/types/http\";\nimport type { IHttpRequest } from \"../types/IHttpRequest\";\nimport { ApiRequestError } from \"@/http/common/ApiRequestError\";\n\nexport class HttpRequest implements IHttpRequest {\n  private baseURL = \"\";\n  private defaultTimeout = 10000;\n  private defaultHeaders: Record<string, string> = {};\n  private withCredentials = true;\n  private maxRetries = 3;\n\n  configure(options: HttpConfigOptions): void {\n    this.baseURL = HttpConfig.getFullBaseUrl(options);\n    this.defaultTimeout = options.timeout ?? 10000;\n    this.maxRetries = options.maxRetries ?? 3;\n    this.withCredentials = options.withCredentials ?? true;\n\n    this.defaultHeaders = {\n      \"Content-Type\": \"application/json\",\n      Accept: \"application/json\",\n      ...options.headers,\n    };\n\n    Interceptor.setupDefaultErrorInterceptor(HttpConfig.logError);\n    Interceptor.addInterceptors(options);\n  }\n\n  public async request<TResponse = any>(\n    config: Partial<RequestConfig> & { url: string; },\n    options: Partial<RequestConfig> = {},\n  ): Promise<TResponse> {\n    try {\n      const mergedConfig = this.createMergedConfig(config, options);\n      const url = this.buildRequestUrl(mergedConfig.url);\n      const interceptedConfig = await this.applyRequestInterceptors(mergedConfig, url);\n\n      let response = await this.executeRequest(url, interceptedConfig);\n      response = await Interceptor.applyResponseSuccessInterceptors(response);\n\n      return await this.parseResponse<TResponse>(response);\n    } catch (error) {\n      return this.handleRequestError(error, config, options);\n    }\n  }\n\n  private createMergedConfig(\n    config: Partial<RequestConfig> & { url: string; },\n    options: Partial<RequestConfig>,\n  ): RequestConfig {\n    return {\n      method: \"GET\",\n      timeout: this.defaultTimeout,\n      ...config,\n      ...options,\n      headers: {\n        ...this.defaultHeaders,\n        ...(config.headers || {}),\n        ...(options.headers || {}),\n      },\n    };\n  }\n\n  private buildRequestUrl(requestUrl: string): string {\n    if (requestUrl.startsWith(\"http\")) {\n      return requestUrl;\n    }\n\n    const prefix = requestUrl.startsWith(\"/\") ? \"\" : \"/\";\n    return new URL(`${this.baseURL}${prefix}${requestUrl}`).toString();\n  }\n\n  private async applyRequestInterceptors(\n    config: RequestConfig,\n    url: string\n  ): Promise<RequestConfig> {\n    return Interceptor.applyRequestInterceptors({\n      ...config,\n      url,\n    });\n  }\n\n  private async executeRequest(url: string, config: RequestConfig): Promise<Response> {\n    return this.fetchWithRetry(\n      url,\n      config,\n      this.maxRetries,\n      this.defaultTimeout,\n      this.withCredentials\n    );\n  }\n\n  private async parseResponse<T>(response: Response): Promise<T> {\n    if (response.headers.get(\"content-type\")?.includes(\"application/json\")) {\n      return await response.json() as T;\n    }\n    return await response.text() as T;\n  }\n\n  private handleRequestError(\n    error: unknown,\n    config: Partial<RequestConfig> & { url: string; },\n    options: Partial<RequestConfig>\n  ): Promise<any> {\n    const apiError = error instanceof ApiRequestError\n      ? error\n      : new ApiRequestError(error, {\n        ...config,\n        ...options,\n        url: config.url,\n      });\n\n    return Interceptor.applyResponseErrorInterceptors(apiError);\n  }\n\n  private isRetryableError(status: number, method?: string): boolean {\n    const idempotentMethods = [\"GET\", \"HEAD\", \"OPTIONS\", \"PUT\", \"DELETE\"];\n    const isIdempotent = !method || idempotentMethods.includes(method.toUpperCase());\n\n    return (\n      isIdempotent &&\n      (status === 0 || status === 429 || (status >= 500 && status < 600))\n    );\n  }\n\n  private async fetchWithRetry(\n    url: string,\n    config: RequestConfig,\n    maxRetries: number,\n    defaultTimeout: number,\n    withCredentials: boolean,\n    attempt: number = 1,\n  ): Promise<Response> {\n    try {\n      const { response, timeoutId } = await this.performFetch(url, config, defaultTimeout, withCredentials);\n      clearTimeout(timeoutId);\n\n      if (!response.ok && this.shouldRetry(response.status, config.method, attempt, maxRetries)) {\n        return this.retryWithBackoff(url, config, maxRetries, defaultTimeout, withCredentials, attempt);\n      }\n\n      return response;\n    } catch (error) {\n      if (error instanceof DOMException && error.name === \"AbortError\") {\n        throw new Error(`Request timeout after ${config.timeout || defaultTimeout}ms`);\n      }\n\n      if (attempt < maxRetries && this.isRetryableError(0, config.method)) {\n        return this.retryWithBackoff(url, config, maxRetries, defaultTimeout, withCredentials, attempt);\n      }\n\n      throw error;\n    }\n  }\n\n  private async performFetch(\n    url: string,\n    config: RequestConfig,\n    defaultTimeout: number,\n    withCredentials: boolean\n  ): Promise<{ response: Response, timeoutId: number | ReturnType<typeof setTimeout>; }> {\n    const {\n      timeout = defaultTimeout,\n      params,\n      data,\n      ...fetchOptions\n    } = config;\n\n    const fullUrl = this.appendQueryParams(url, params);\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(\"Request timeout\"), timeout);\n    const body = this.prepareRequestBody(data);\n\n    const response = await fetch(fullUrl, {\n      ...fetchOptions,\n      body,\n      signal: controller.signal,\n      credentials: withCredentials ? \"include\" : \"same-origin\",\n    });\n\n    return { response, timeoutId };\n  }\n\n  private appendQueryParams(url: string, params?: Record<string, string>): string {\n    if (!params || Object.keys(params).length === 0) {\n      return url;\n    }\n\n    const queryParams = new URLSearchParams();\n    for (const [key, value] of Object.entries(params)) {\n      queryParams.append(key, value);\n    }\n\n    return `${url}?${queryParams.toString()}`;\n  }\n\n  private prepareRequestBody(data: any): string | undefined {\n    if (data === undefined) {\n      return undefined;\n    }\n\n    return typeof data === \"string\" ? data : JSON.stringify(data);\n  }\n\n  private shouldRetry(status: number, method?: string, attempt?: number, maxRetries?: number): boolean {\n    return (\n      attempt !== undefined &&\n      maxRetries !== undefined &&\n      attempt < maxRetries &&\n      this.isRetryableError(status, method)\n    );\n  }\n\n  private async retryWithBackoff(\n    url: string,\n    config: RequestConfig,\n    maxRetries: number,\n    defaultTimeout: number,\n    withCredentials: boolean,\n    attempt: number\n  ): Promise<Response> {\n    const delay = Math.pow(2, attempt) * 100;\n    await new Promise(resolve => setTimeout(resolve, delay));\n\n    return this.fetchWithRetry(\n      url,\n      config,\n      maxRetries,\n      defaultTimeout,\n      withCredentials,\n      attempt + 1\n    );\n  }\n}"],"names":[],"mappings":";;;;;;AAMO,MAAM,YAAoC;AAAA,EAA1C;AACG,mCAAU;AACV,0CAAiB;AACjB,0CAAyC,CAAC;AAC1C,2CAAkB;AAClB,sCAAa;AAAA;AAAA,EAErB,UAAU,SAAkC;AACrC,SAAA,UAAU,WAAW,eAAe,OAAO;AAC3C,SAAA,iBAAiB,QAAQ,WAAW;AACpC,SAAA,aAAa,QAAQ,cAAc;AACnC,SAAA,kBAAkB,QAAQ,mBAAmB;AAElD,SAAK,iBAAiB;AAAA,MACpB,gBAAgB;AAAA,MAChB,QAAQ;AAAA,MACR,GAAG,QAAQ;AAAA,IACb;AAEY,gBAAA,6BAA6B,WAAW,QAAQ;AAC5D,gBAAY,gBAAgB,OAAO;AAAA,EAAA;AAAA,EAGrC,MAAa,QACX,QACA,UAAkC,IACd;AAChB,QAAA;AACF,YAAM,eAAe,KAAK,mBAAmB,QAAQ,OAAO;AAC5D,YAAM,MAAM,KAAK,gBAAgB,aAAa,GAAG;AACjD,YAAM,oBAAoB,MAAM,KAAK,yBAAyB,cAAc,GAAG;AAE/E,UAAI,WAAW,MAAM,KAAK,eAAe,KAAK,iBAAiB;AACpD,iBAAA,MAAM,YAAY,iCAAiC,QAAQ;AAE/D,aAAA,MAAM,KAAK,cAAyB,QAAQ;AAAA,aAC5C,OAAO;AACd,aAAO,KAAK,mBAAmB,OAAO,QAAQ,OAAO;AAAA,IAAA;AAAA,EACvD;AAAA,EAGM,mBACN,QACA,SACe;AACR,WAAA;AAAA,MACL,QAAQ;AAAA,MACR,SAAS,KAAK;AAAA,MACd,GAAG;AAAA,MACH,GAAG;AAAA,MACH,SAAS;AAAA,QACP,GAAG,KAAK;AAAA,QACR,GAAI,OAAO,WAAW,CAAC;AAAA,QACvB,GAAI,QAAQ,WAAW,CAAA;AAAA,MAAC;AAAA,IAE5B;AAAA,EAAA;AAAA,EAGM,gBAAgB,YAA4B;AAC9C,QAAA,WAAW,WAAW,MAAM,GAAG;AAC1B,aAAA;AAAA,IAAA;AAGT,UAAM,SAAS,WAAW,WAAW,GAAG,IAAI,KAAK;AAC1C,WAAA,IAAI,IAAI,GAAG,KAAK,OAAO,GAAG,MAAM,GAAG,UAAU,EAAE,EAAE,SAAS;AAAA,EAAA;AAAA,EAGnE,MAAc,yBACZ,QACA,KACwB;AACxB,WAAO,YAAY,yBAAyB;AAAA,MAC1C,GAAG;AAAA,MACH;AAAA,IAAA,CACD;AAAA,EAAA;AAAA,EAGH,MAAc,eAAe,KAAa,QAA0C;AAClF,WAAO,KAAK;AAAA,MACV;AAAA,MACA;AAAA,MACA,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AAAA,EAAA;AAAA,EAGF,MAAc,cAAiB,UAAgC;;AAC7D,SAAI,cAAS,QAAQ,IAAI,cAAc,MAAnC,mBAAsC,SAAS,qBAAqB;AAC/D,aAAA,MAAM,SAAS,KAAK;AAAA,IAAA;AAEtB,WAAA,MAAM,SAAS,KAAK;AAAA,EAAA;AAAA,EAGrB,mBACN,OACA,QACA,SACc;AACd,UAAM,WAAW,iBAAiB,kBAC9B,QACA,IAAI,gBAAgB,OAAO;AAAA,MAC3B,GAAG;AAAA,MACH,GAAG;AAAA,MACH,KAAK,OAAO;AAAA,IAAA,CACb;AAEI,WAAA,YAAY,+BAA+B,QAAQ;AAAA,EAAA;AAAA,EAGpD,iBAAiB,QAAgB,QAA0B;AACjE,UAAM,oBAAoB,CAAC,OAAO,QAAQ,WAAW,OAAO,QAAQ;AACpE,UAAM,eAAe,CAAC,UAAU,kBAAkB,SAAS,OAAO,aAAa;AAE/E,WACE,iBACC,WAAW,KAAK,WAAW,OAAQ,UAAU,OAAO,SAAS;AAAA,EAAA;AAAA,EAIlE,MAAc,eACZ,KACA,QACA,YACA,gBACA,iBACA,UAAkB,GACC;AACf,QAAA;AACI,YAAA,EAAE,UAAU,UAAA,IAAc,MAAM,KAAK,aAAa,KAAK,QAAQ,gBAAgB,eAAe;AACpG,mBAAa,SAAS;AAElB,UAAA,CAAC,SAAS,MAAM,KAAK,YAAY,SAAS,QAAQ,OAAO,QAAQ,SAAS,UAAU,GAAG;AACzF,eAAO,KAAK,iBAAiB,KAAK,QAAQ,YAAY,gBAAgB,iBAAiB,OAAO;AAAA,MAAA;AAGzF,aAAA;AAAA,aACA,OAAO;AACd,UAAI,iBAAiB,gBAAgB,MAAM,SAAS,cAAc;AAChE,cAAM,IAAI,MAAM,yBAAyB,OAAO,WAAW,cAAc,IAAI;AAAA,MAAA;AAG/E,UAAI,UAAU,cAAc,KAAK,iBAAiB,GAAG,OAAO,MAAM,GAAG;AACnE,eAAO,KAAK,iBAAiB,KAAK,QAAQ,YAAY,gBAAgB,iBAAiB,OAAO;AAAA,MAAA;AAG1F,YAAA;AAAA,IAAA;AAAA,EACR;AAAA,EAGF,MAAc,aACZ,KACA,QACA,gBACA,iBACqF;AAC/E,UAAA;AAAA,MACJ,UAAU;AAAA,MACV;AAAA,MACA;AAAA,MACA,GAAG;AAAA,IAAA,IACD;AAEJ,UAAM,UAAU,KAAK,kBAAkB,KAAK,MAAM;AAC5C,UAAA,aAAa,IAAI,gBAAgB;AACvC,UAAM,YAAY,WAAW,MAAM,WAAW,MAAM,iBAAiB,GAAG,OAAO;AACzE,UAAA,OAAO,KAAK,mBAAmB,IAAI;AAEnC,UAAA,WAAW,MAAM,MAAM,SAAS;AAAA,MACpC,GAAG;AAAA,MACH;AAAA,MACA,QAAQ,WAAW;AAAA,MACnB,aAAa,kBAAkB,YAAY;AAAA,IAAA,CAC5C;AAEM,WAAA,EAAE,UAAU,UAAU;AAAA,EAAA;AAAA,EAGvB,kBAAkB,KAAa,QAAyC;AAC9E,QAAI,CAAC,UAAU,OAAO,KAAK,MAAM,EAAE,WAAW,GAAG;AACxC,aAAA;AAAA,IAAA;AAGH,UAAA,cAAc,IAAI,gBAAgB;AACxC,eAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,MAAM,GAAG;AACrC,kBAAA,OAAO,KAAK,KAAK;AAAA,IAAA;AAG/B,WAAO,GAAG,GAAG,IAAI,YAAY,SAAU,CAAA;AAAA,EAAA;AAAA,EAGjC,mBAAmB,MAA+B;AACxD,QAAI,SAAS,QAAW;AACf,aAAA;AAAA,IAAA;AAGT,WAAO,OAAO,SAAS,WAAW,OAAO,KAAK,UAAU,IAAI;AAAA,EAAA;AAAA,EAGtD,YAAY,QAAgB,QAAiB,SAAkB,YAA8B;AAEjG,WAAA,YAAY,UACZ,eAAe,UACf,UAAU,cACV,KAAK,iBAAiB,QAAQ,MAAM;AAAA,EAAA;AAAA,EAIxC,MAAc,iBACZ,KACA,QACA,YACA,gBACA,iBACA,SACmB;AACnB,UAAM,QAAQ,KAAK,IAAI,GAAG,OAAO,IAAI;AACrC,UAAM,IAAI,QAAQ,CAAA,YAAW,WAAW,SAAS,KAAK,CAAC;AAEvD,WAAO,KAAK;AAAA,MACV;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,UAAU;AAAA,IACZ;AAAA,EAAA;AAEJ;"}