{"version":3,"file":"HttpRequest.js","sources":["../../../../src/http/common/HttpRequest.ts"],"sourcesContent":["import { HttpConfig } from \"./HttpConfig\";\nimport { Interceptor } from \"./Interceptor\";\nimport type { HttpConfigOptions, RequestConfig } from \"@/http/types/http\";\nimport type { IHttpRequest } from \"../types/IHttpRequest\";\nimport { ApiRequestError } from \"@/http/common/ApiRequestError\";\n\nexport class HttpRequest implements IHttpRequest {\n  private baseURL = \"\";\n  private defaultTimeout = 10000;\n  private defaultHeaders: Record<string, string> = {};\n  private withCredentials = true;\n  private maxRetries = 3;\n\n  configure(options: HttpConfigOptions): void {\n    this.baseURL = HttpConfig.getFullBaseUrl(options);\n    this.defaultTimeout = options.timeout ?? 10000;\n    this.maxRetries = options.maxRetries ?? 3;\n    this.withCredentials = options.withCredentials ?? true;\n\n    this.defaultHeaders = {\n      \"Content-Type\": \"application/json\",\n      Accept: \"application/json\",\n      ...options.headers,\n    };\n\n    Interceptor.setupDefaultErrorInterceptor(HttpConfig.logError);\n    Interceptor.addInterceptors(options);\n  }\n\n  public async request<TResponse = any>(\n    config: Partial<RequestConfig> & { url: string },\n    options: Partial<RequestConfig> = {},\n  ): Promise<TResponse> {\n    try {\n      const mergedConfig = this.createMergedConfig(config, options);\n      const url = this.buildRequestUrl(mergedConfig.url);\n      const interceptedConfig = await this.applyRequestInterceptors(\n        mergedConfig,\n        url,\n      );\n\n      let response = await this.executeRequest(url, interceptedConfig);\n      response = await Interceptor.applyResponseSuccessInterceptors(response);\n\n      return await this.parseResponse<TResponse>(response);\n    } catch (error) {\n      return this.handleRequestError(error, config, options);\n    }\n  }\n\n  private createMergedConfig(\n    config: Partial<RequestConfig> & { url: string },\n    options: Partial<RequestConfig>,\n  ): RequestConfig {\n    return {\n      method: \"GET\",\n      timeout: this.defaultTimeout,\n      ...config,\n      ...options,\n      headers: {\n        ...this.defaultHeaders,\n        ...(config.headers || {}),\n        ...(options.headers || {}),\n      },\n    };\n  }\n\n  private buildRequestUrl(requestUrl: string): string {\n    if (requestUrl.startsWith(\"http\")) {\n      return requestUrl;\n    }\n\n    const prefix = requestUrl.startsWith(\"/\") ? \"\" : \"/\";\n    return new URL(`${this.baseURL}${prefix}${requestUrl}`).toString();\n  }\n\n  private async applyRequestInterceptors(\n    config: RequestConfig,\n    url: string,\n  ): Promise<RequestConfig> {\n    return Interceptor.applyRequestInterceptors({\n      ...config,\n      url,\n    });\n  }\n\n  private async executeRequest(\n    url: string,\n    config: RequestConfig,\n  ): Promise<Response> {\n    return this.fetchWithRetry(\n      url,\n      config,\n      this.maxRetries,\n      this.defaultTimeout,\n      this.withCredentials,\n    );\n  }\n\n  private async parseResponse<T>(response: Response): Promise<T> {\n    if (response.headers.get(\"content-type\")?.includes(\"application/json\")) {\n      return (await response.json()) as T;\n    }\n    return (await response.text()) as T;\n  }\n\n  private handleRequestError(\n    error: unknown,\n    config: Partial<RequestConfig> & { url: string },\n    options: Partial<RequestConfig>,\n  ): Promise<any> {\n    const apiError =\n      error instanceof ApiRequestError\n        ? error\n        : new ApiRequestError(error, {\n            ...config,\n            ...options,\n            url: config.url,\n          });\n\n    return Interceptor.applyResponseErrorInterceptors(apiError);\n  }\n\n  private isRetryableError(status: number, method?: string): boolean {\n    const idempotentMethods = [\"GET\", \"HEAD\", \"OPTIONS\", \"PUT\", \"DELETE\"];\n    const isIdempotent =\n      !method || idempotentMethods.includes(method.toUpperCase());\n\n    return (\n      isIdempotent &&\n      (status === 0 || status === 429 || (status >= 500 && status < 600))\n    );\n  }\n\n  private async fetchWithRetry(\n    url: string,\n    config: RequestConfig,\n    maxRetries: number,\n    defaultTimeout: number,\n    withCredentials: boolean,\n    attempt: number = 1,\n  ): Promise<Response> {\n    try {\n      const { response, timeoutId } = await this.performFetch(\n        url,\n        config,\n        defaultTimeout,\n        withCredentials,\n      );\n      clearTimeout(timeoutId);\n\n      if (\n        !response.ok &&\n        this.shouldRetry(response.status, config.method, attempt, maxRetries)\n      ) {\n        return this.retryWithBackoff(\n          url,\n          config,\n          maxRetries,\n          defaultTimeout,\n          withCredentials,\n          attempt,\n        );\n      }\n\n      return response;\n    } catch (error) {\n      if (error instanceof DOMException && error.name === \"AbortError\") {\n        throw new Error(\n          `Request timeout after ${config.timeout || defaultTimeout}ms`,\n        );\n      }\n\n      if (attempt < maxRetries && this.isRetryableError(0, config.method)) {\n        return this.retryWithBackoff(\n          url,\n          config,\n          maxRetries,\n          defaultTimeout,\n          withCredentials,\n          attempt,\n        );\n      }\n\n      throw error;\n    }\n  }\n\n  private async performFetch(\n    url: string,\n    config: RequestConfig,\n    defaultTimeout: number,\n    withCredentials: boolean,\n  ): Promise<{\n    response: Response;\n    timeoutId: number | ReturnType<typeof setTimeout>;\n  }> {\n    const { timeout = defaultTimeout, params, data, ...fetchOptions } = config;\n\n    const fullUrl = this.appendQueryParams(url, params);\n    const controller = new AbortController();\n    const timeoutId = setTimeout(\n      () => controller.abort(\"Request timeout\"),\n      timeout,\n    );\n    const body = this.prepareRequestBody(data);\n\n    const response = await fetch(fullUrl, {\n      ...fetchOptions,\n      body,\n      signal: controller.signal,\n      credentials: withCredentials ? \"include\" : \"same-origin\",\n    });\n\n    return { response, timeoutId };\n  }\n\n  private appendQueryParams(\n    url: string,\n    params?: Record<string, string>,\n  ): string {\n    if (!params || Object.keys(params).length === 0) {\n      return url;\n    }\n\n    const queryParams = new URLSearchParams();\n    for (const [key, value] of Object.entries(params)) {\n      queryParams.append(key, value);\n    }\n\n    return `${url}?${queryParams.toString()}`;\n  }\n\n  private prepareRequestBody(data: any): string | undefined {\n    if (data === undefined) {\n      return undefined;\n    }\n\n    return typeof data === \"string\" ? data : JSON.stringify(data);\n  }\n\n  private shouldRetry(\n    status: number,\n    method?: string,\n    attempt?: number,\n    maxRetries?: number,\n  ): boolean {\n    return (\n      attempt !== undefined &&\n      maxRetries !== undefined &&\n      attempt < maxRetries &&\n      this.isRetryableError(status, method)\n    );\n  }\n\n  private async retryWithBackoff(\n    url: string,\n    config: RequestConfig,\n    maxRetries: number,\n    defaultTimeout: number,\n    withCredentials: boolean,\n    attempt: number,\n  ): Promise<Response> {\n    const delay = Math.pow(2, attempt) * 100;\n    await new Promise((resolve) => setTimeout(resolve, delay));\n\n    return this.fetchWithRetry(\n      url,\n      config,\n      maxRetries,\n      defaultTimeout,\n      withCredentials,\n      attempt + 1,\n    );\n  }\n}\n"],"names":[],"mappings":"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"}