{"version":3,"file":"HttpHandler.js","sources":["../../../../src/http/request/HttpHandler.ts"],"sourcesContent":["import type {\n  FetchResult,\n  HandlerConfig,\n  RequestConfig,\n  RetryOptions,\n} from \"@/http/types\";\n\nexport class HttpHandler {\n  private readonly idempotentMethods = [\n    \"GET\",\n    \"HEAD\",\n    \"OPTIONS\",\n    \"PUT\",\n    \"DELETE\",\n  ];\n  private maxRetries = 3;\n  private defaultTimeout = 10000;\n  private withCredentials = true;\n\n  configure(config: HandlerConfig): void {\n    this.maxRetries = config.maxRetries;\n    this.defaultTimeout = config.defaultTimeout;\n    this.withCredentials = config.withCredentials;\n  }\n\n  async executeRequest(url: string, config: RequestConfig): Promise<Response> {\n    return this.fetchWithRetry(url, config, {\n      maxRetries: this.maxRetries,\n      defaultTimeout: this.defaultTimeout,\n      withCredentials: this.withCredentials,\n      attempt: 1,\n    });\n  }\n\n  async parseResponse<T>(response: Response): Promise<T> {\n    const contentType = response.headers.get(\"content-type\");\n\n    if (contentType?.includes(\"application/json\")) {\n      return (await response.json()) as T;\n    }\n\n    return (await response.text()) as unknown as T;\n  }\n\n  private async fetchWithRetry(\n    url: string,\n    config: RequestConfig,\n    retryOptions: RetryOptions,\n  ): Promise<Response> {\n    const { maxRetries, attempt, defaultTimeout, withCredentials } =\n      retryOptions;\n\n    try {\n      const { response, timeoutId } = await this.performFetch(\n        url,\n        config,\n        defaultTimeout,\n        withCredentials,\n      );\n\n      clearTimeout(timeoutId);\n\n      if (\n        !response.ok &&\n        this.shouldRetry(response.status, config.method, attempt, maxRetries)\n      ) {\n        return this.retryWithBackoff(url, config, {\n          maxRetries,\n          defaultTimeout,\n          withCredentials,\n          attempt,\n        });\n      }\n\n      return response;\n    } catch (error) {\n      if (error instanceof DOMException && error.name === \"AbortError\") {\n        throw new Error(\n          `Request timeout after ${config.timeout || defaultTimeout}ms`,\n        );\n      }\n\n      if (attempt < maxRetries && this.isRetryableError(0, config.method)) {\n        return this.retryWithBackoff(url, config, {\n          maxRetries,\n          defaultTimeout,\n          withCredentials,\n          attempt,\n        });\n      }\n\n      throw error;\n    }\n  }\n\n  private async performFetch(\n    url: string,\n    config: RequestConfig,\n    defaultTimeout: number,\n    withCredentials: boolean,\n  ): Promise<FetchResult> {\n    const { timeout = defaultTimeout, params, data, ...fetchOptions } = config;\n\n    const fullUrl = this.appendQueryParams(url, params);\n    const controller = new AbortController();\n    const timeoutId = setTimeout(\n      () => controller.abort(\"Request timeout\"),\n      timeout,\n    );\n    const body = this.prepareRequestBody(data);\n\n    const response = await fetch(fullUrl, {\n      ...fetchOptions,\n      body,\n      signal: controller.signal,\n      credentials: withCredentials ? \"include\" : \"same-origin\",\n    });\n\n    return { response, timeoutId };\n  }\n\n  private prepareRequestBody(data: unknown): string | undefined {\n    if (data === undefined) {\n      return undefined;\n    }\n\n    return typeof data === \"string\" ? data : JSON.stringify(data);\n  }\n\n  private appendQueryParams(\n    url: string,\n    params?: Record<string, string>,\n  ): string {\n    if (!params || Object.keys(params).length === 0) {\n      return url;\n    }\n\n    const queryParams = new URLSearchParams();\n    for (const [key, value] of Object.entries(params)) {\n      queryParams.append(key, value);\n    }\n\n    return `${url}?${queryParams.toString()}`;\n  }\n\n  private isRetryableError(status: number, method?: string): boolean {\n    const isIdempotent =\n      !method || this.idempotentMethods.includes(method.toUpperCase());\n\n    return (\n      isIdempotent &&\n      (status === 0 || status === 429 || (status >= 500 && status < 600))\n    );\n  }\n\n  private shouldRetry(\n    status: number,\n    method?: string,\n    attempt?: number,\n    maxRetries?: number,\n  ): boolean {\n    return (\n      attempt !== undefined &&\n      maxRetries !== undefined &&\n      attempt < maxRetries &&\n      this.isRetryableError(status, method)\n    );\n  }\n\n  private async retryWithBackoff(\n    url: string,\n    config: RequestConfig,\n    retryOptions: RetryOptions,\n  ): Promise<Response> {\n    const { maxRetries, attempt, defaultTimeout, withCredentials } =\n      retryOptions;\n\n    const delay = Math.pow(2, attempt) * 100;\n    await new Promise((resolve) => setTimeout(resolve, delay));\n\n    return this.fetchWithRetry(url, config, {\n      maxRetries,\n      defaultTimeout,\n      withCredentials,\n      attempt: attempt + 1,\n    });\n  }\n}\n"],"names":[],"mappings":"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"}