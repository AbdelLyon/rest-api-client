{"version":3,"file":"HttpClient.js","sources":["../../../src/http/HttpClient.ts"],"sourcesContent":["import type { HttpConfig, HttpConfigOptions, RequestConfig, RequestInterceptor, ResponseErrorInterceptor, ResponseSuccessInterceptor } from \"@/http/types/http\";\nimport type { IHttpClient } from \"@/http/interface/IHttpClient\";\nimport { ApiRequestError } from \"@/error/ApiRequestError\";\n\nexport class HttpClient implements IHttpClient {\n  private static instances: Map<string, HttpClient> = new Map();\n  private static defaultInstanceName: string;\n\n  private static requestInterceptors: Array<RequestInterceptor> = [];\n  private static responseSuccessInterceptors: Array<ResponseSuccessInterceptor> = [];\n  private static responseErrorInterceptors: Array<ResponseErrorInterceptor> = [];\n\n  private baseURL: string;\n  private defaultTimeout: number;\n  private defaultHeaders: Record<string, string>;\n  private withCredentials: boolean;\n  private maxRetries: number;\n\n  private constructor () {\n    this.baseURL = \"\";\n    this.defaultTimeout = 10000;\n    this.defaultHeaders = {};\n    this.withCredentials = true;\n    this.maxRetries = 3;\n  }\n\n\n  static init(config: {\n    httpConfig: HttpConfig;\n    instanceName: string;\n  }): HttpClient {\n    const { httpConfig, instanceName } = config;\n\n    HttpClient.requestInterceptors = [\n      ...HttpClient.requestInterceptors,\n      ...(httpConfig.interceptors?.request ?? [])\n    ];\n\n    if (httpConfig.interceptors?.response) {\n      HttpClient.responseSuccessInterceptors = [\n        ...HttpClient.responseSuccessInterceptors,\n        ...(httpConfig.interceptors.response.success ?? [])\n      ];\n\n      HttpClient.responseErrorInterceptors = [\n        ...HttpClient.responseErrorInterceptors,\n        ...(httpConfig.interceptors.response.error ?? [])\n      ];\n    }\n\n    if (!this.instances.has(instanceName)) {\n      const instance = new HttpClient();\n      instance.configure(httpConfig);\n      this.instances.set(instanceName, instance);\n\n      if (this.instances.size === 1) {\n        this.defaultInstanceName = instanceName;\n      }\n    }\n    return this.instances.get(instanceName)!;\n  }\n\n  static getInstance(instanceName?: string): HttpClient {\n    const name = instanceName || this.defaultInstanceName;\n\n    if (!this.instances.has(name)) {\n      throw new Error(\n        `Http instance '${name}' not initialized. Call Http.init() first.`,\n      );\n    }\n    return this.instances.get(name)!;\n  }\n\n\n  static setDefaultInstance(instanceName: string): void {\n    if (!this.instances.has(instanceName)) {\n      throw new Error(\n        `Cannot set default: Http instance '${instanceName}' not initialized.`,\n      );\n    }\n    this.defaultInstanceName = instanceName;\n  }\n\n  static getAvailableInstances(): Array<string> {\n    return Array.from(this.instances.keys());\n  }\n\n  static resetInstance(instanceName?: string): void {\n    if (instanceName) {\n      this.instances.delete(instanceName);\n\n      if (\n        instanceName === this.defaultInstanceName &&\n        this.instances.size > 0\n      ) {\n        this.defaultInstanceName =\n          this.instances.keys().next().value ?? \"default\";\n      }\n    } else {\n      this.instances.clear();\n      this.defaultInstanceName = \"default\";\n    }\n  }\n\n  private configure(options: HttpConfigOptions): void {\n\n    this.baseURL = this.getFullBaseUrl(options);\n    this.defaultTimeout = options.timeout ?? 10000;\n    this.maxRetries = options.maxRetries ?? 3;\n    this.withCredentials = options.withCredentials ?? true;\n\n    this.defaultHeaders = {\n      \"Content-Type\": \"application/json\",\n      \"Accept\": \"application/json\",\n      ...options.headers,\n    };\n\n    this.setupDefaultInterceptors();\n  }\n\n  private getFullBaseUrl(options: HttpConfigOptions): string {\n    if (!options.baseURL) {\n      throw new Error(\"baseURL is required in HttpConfigOptions\");\n    }\n\n    let baseUrl = options.baseURL.trim();\n    if (baseUrl.endsWith(\"/\")) {\n      baseUrl = baseUrl.slice(0, -1);\n    }\n\n    if (options.apiPrefix) {\n      let prefix = options.apiPrefix.trim();\n      if (!prefix.startsWith(\"/\")) {\n        prefix = \"/\" + prefix;\n      }\n      if (prefix.endsWith(\"/\")) {\n        prefix = prefix.slice(0, -1);\n      }\n\n      return baseUrl + prefix;\n    }\n\n    if (options.apiVersion) {\n      return `${baseUrl}/v${options.apiVersion}`;\n    }\n\n    return baseUrl;\n  }\n\n  private setupDefaultInterceptors(): void {\n\n    if (HttpClient.responseErrorInterceptors.length === 0) {\n      HttpClient.responseErrorInterceptors.push((error) => {\n        this.logError(error);\n        return Promise.reject(error);\n      });\n    }\n  }\n\n  private logError(error: any): void {\n    const errorDetails = {\n      url: error.config?.url,\n      method: error.config?.method,\n      status: error.status,\n      data: error.data,\n      message: error.message,\n    };\n\n    console.error(\"API Request Error\", errorDetails);\n  }\n\n  private async applyRequestInterceptors(config: RequestConfig): Promise<RequestConfig> {\n    let interceptedConfig = { ...config };\n\n    for (const interceptor of HttpClient.requestInterceptors) {\n      interceptedConfig = await Promise.resolve(interceptor(interceptedConfig));\n    }\n\n    return interceptedConfig;\n  }\n\n  private async applyResponseSuccessInterceptors(response: Response): Promise<Response> {\n    let interceptedResponse = response;\n\n    for (const interceptor of HttpClient.responseSuccessInterceptors) {\n      interceptedResponse = await Promise.resolve(interceptor(interceptedResponse.clone()));\n    }\n\n    return interceptedResponse;\n  }\n\n  private async applyResponseErrorInterceptors(error: any): Promise<any> {\n    let interceptedError = error;\n\n    for (const interceptor of HttpClient.responseErrorInterceptors) {\n      try {\n        interceptedError = await Promise.resolve(interceptor(interceptedError));\n\n        if (!(interceptedError instanceof Error)) {\n          return interceptedError;\n        }\n      } catch (e) {\n        interceptedError = e;\n      }\n    }\n\n    return Promise.reject(interceptedError);\n  }\n\n  private isRetryableError(status: number, method?: string): boolean {\n    const idempotentMethods = ['GET', 'HEAD', 'OPTIONS', 'PUT', 'DELETE'];\n    const isIdempotent = !method || idempotentMethods.includes(method.toUpperCase());\n\n    return (\n      isIdempotent && (\n        status === 0 ||\n        status === 429 ||\n        (status >= 500 && status < 600)\n      )\n    );\n  }\n\n  private async fetchWithRetry(\n    url: string,\n    config: RequestConfig,\n    attempt: number = 1\n  ): Promise<Response> {\n    try {\n      const { timeout = this.defaultTimeout, params, data, ...fetchOptions } = config;\n      let fullUrl = url;\n\n      if (params && Object.keys(params).length > 0) {\n        const queryParams = new URLSearchParams();\n        for (const [key, value] of Object.entries(params)) {\n          queryParams.append(key, value);\n        }\n        fullUrl += `?${queryParams.toString()}`;\n      }\n\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort('Request timeout'), timeout);\n\n      let body: any = undefined;\n      if (data !== undefined) {\n        body = typeof data === 'string' ? data : JSON.stringify(data);\n      }\n\n      const response = await fetch(fullUrl, {\n        ...fetchOptions,\n        body,\n        signal: controller.signal,\n        credentials: this.withCredentials ? 'include' : 'same-origin',\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        if (\n          attempt < this.maxRetries &&\n          this.isRetryableError(response.status, config.method)\n        ) {\n          const delay = Math.pow(2, attempt) * 100;\n          await new Promise(resolve => setTimeout(resolve, delay));\n          return this.fetchWithRetry(url, config, attempt + 1);\n        }\n      }\n\n      return response;\n\n    } catch (error) {\n      if (error instanceof DOMException && error.name === 'AbortError') {\n        throw new Error(`Request timeout after ${config.timeout || this.defaultTimeout}ms`);\n      }\n\n      if (attempt < this.maxRetries && this.isRetryableError(0, config.method)) {\n        const delay = Math.pow(2, attempt) * 100;\n        await new Promise(resolve => setTimeout(resolve, delay));\n        return this.fetchWithRetry(url, config, attempt + 1);\n      }\n\n      throw error;\n    }\n  }\n\n  public async request<TResponse = any>(\n    config: Partial<RequestConfig> & { url: string; },\n    options: Partial<RequestConfig> = {},\n  ): Promise<TResponse> {\n    try {\n      const mergedConfig: RequestConfig = {\n        method: 'GET',\n        timeout: this.defaultTimeout,\n        ...config,\n        ...options,\n        headers: {\n          ...this.defaultHeaders,\n          ...(config.headers || {}),\n          ...(options.headers || {})\n        }\n      };\n\n      const url = new URL(\n        mergedConfig.url.startsWith('http')\n          ? mergedConfig.url\n          : `${this.baseURL}${mergedConfig.url.startsWith('/') ? '' : '/'}${mergedConfig.url}`\n      ).toString();\n\n      const interceptedConfig = await this.applyRequestInterceptors({\n        ...mergedConfig,\n        url\n      });\n\n      let response = await this.fetchWithRetry(url, interceptedConfig);\n\n      response = await this.applyResponseSuccessInterceptors(response);\n\n      if (response.headers.get('content-type')?.includes('application/json')) {\n        return await response.json() as TResponse;\n      } else {\n        return await response.text() as TResponse;\n      }\n\n    } catch (error) {\n      const apiError = error instanceof ApiRequestError\n        ? error\n        : new ApiRequestError(error, {\n          ...config,\n          ...options,\n          url: config.url\n        });\n\n      return this.applyResponseErrorInterceptors(apiError);\n    }\n  }\n}"],"names":[],"mappings":"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"}