{"version":3,"file":"HttpInterceptor.js","sources":["../../../../src/http/Request/HttpInterceptor.ts"],"sourcesContent":["import type {\n  HttpConfig,\n  RequestConfig,\n  RequestInterceptor,\n  ResponseErrorInterceptor,\n  ResponseSuccessInterceptor,\n} from \"@/http/types\";\n\nexport class HttpInterceptor {\n  private static requestInterceptors: Array<RequestInterceptor> = [];\n  private static responseSuccessInterceptors: Array<ResponseSuccessInterceptor> =\n    [];\n  private static responseErrorInterceptors: Array<ResponseErrorInterceptor> =\n    [];\n\n  static addInterceptors(httpConfig: HttpConfig): void {\n    this.requestInterceptors = [\n      ...this.requestInterceptors,\n      ...(httpConfig.interceptors?.request ?? []),\n    ];\n\n    if (httpConfig.interceptors?.response) {\n      this.responseSuccessInterceptors = [\n        ...this.responseSuccessInterceptors,\n        ...(httpConfig.interceptors.response.success ?? []),\n      ];\n\n      this.responseErrorInterceptors = [\n        ...this.responseErrorInterceptors,\n        ...(httpConfig.interceptors.response.error ?? []),\n      ];\n    }\n  }\n\n  static async applyRequestInterceptors(\n    config: RequestConfig,\n  ): Promise<RequestConfig> {\n    let interceptedConfig = { ...config };\n\n    for (const interceptor of this.requestInterceptors) {\n      interceptedConfig = await Promise.resolve(interceptor(interceptedConfig));\n    }\n\n    return interceptedConfig;\n  }\n\n  static async applyResponseSuccessInterceptors(\n    response: Response,\n  ): Promise<Response> {\n    let interceptedResponse = response;\n\n    for (const interceptor of this.responseSuccessInterceptors) {\n      interceptedResponse = await Promise.resolve(\n        interceptor(interceptedResponse.clone()),\n      );\n    }\n\n    return interceptedResponse;\n  }\n\n  static async applyResponseErrorInterceptors(error: Error): Promise<Error> {\n    let interceptedError = error;\n\n    for (const interceptor of this.responseErrorInterceptors) {\n      try {\n        interceptedError = await Promise.resolve(interceptor(interceptedError));\n\n        if (!(interceptedError instanceof Error)) {\n          return interceptedError;\n        }\n      } catch (e) {\n        interceptedError =\n          e instanceof Error ? e : new Error(\"Unknown error occurred\");\n      }\n    }\n\n    return Promise.reject(interceptedError);\n  }\n\n  static setupDefaultErrorInterceptor(\n    logCallback: (error: Error) => void,\n  ): void {\n    if (this.responseErrorInterceptors.length === 0) {\n      this.responseErrorInterceptors.push((error) => {\n        logCallback(error);\n        return Promise.reject(error);\n      });\n    }\n  }\n}\n"],"names":[],"mappings":";;;AAQO,MAAM,gBAAgB;AAAA,EAO3B,OAAO,gBAAgB,YAA8B;AAPhD;AAQH,SAAK,sBAAsB;AAAA,MACzB,GAAG,KAAK;AAAA,MACR,KAAI,gBAAW,iBAAX,mBAAyB,YAAW,CAAA;AAAA,IAC1C;AAEI,SAAA,gBAAW,iBAAX,mBAAyB,UAAU;AACrC,WAAK,8BAA8B;AAAA,QACjC,GAAG,KAAK;AAAA,QACR,GAAI,WAAW,aAAa,SAAS,WAAW,CAAA;AAAA,MAClD;AAEA,WAAK,4BAA4B;AAAA,QAC/B,GAAG,KAAK;AAAA,QACR,GAAI,WAAW,aAAa,SAAS,SAAS,CAAA;AAAA,MAChD;AAAA,IAAA;AAAA,EACF;AAAA,EAGF,aAAa,yBACX,QACwB;AACpB,QAAA,oBAAoB,EAAE,GAAG,OAAO;AAEzB,eAAA,eAAe,KAAK,qBAAqB;AAClD,0BAAoB,MAAM,QAAQ,QAAQ,YAAY,iBAAiB,CAAC;AAAA,IAAA;AAGnE,WAAA;AAAA,EAAA;AAAA,EAGT,aAAa,iCACX,UACmB;AACnB,QAAI,sBAAsB;AAEf,eAAA,eAAe,KAAK,6BAA6B;AAC1D,4BAAsB,MAAM,QAAQ;AAAA,QAClC,YAAY,oBAAoB,MAAO,CAAA;AAAA,MACzC;AAAA,IAAA;AAGK,WAAA;AAAA,EAAA;AAAA,EAGT,aAAa,+BAA+B,OAA8B;AACxE,QAAI,mBAAmB;AAEZ,eAAA,eAAe,KAAK,2BAA2B;AACpD,UAAA;AACF,2BAAmB,MAAM,QAAQ,QAAQ,YAAY,gBAAgB,CAAC;AAElE,YAAA,EAAE,4BAA4B,QAAQ;AACjC,iBAAA;AAAA,QAAA;AAAA,eAEF,GAAG;AACV,2BACE,aAAa,QAAQ,IAAI,IAAI,MAAM,wBAAwB;AAAA,MAAA;AAAA,IAC/D;AAGK,WAAA,QAAQ,OAAO,gBAAgB;AAAA,EAAA;AAAA,EAGxC,OAAO,6BACL,aACM;AACF,QAAA,KAAK,0BAA0B,WAAW,GAAG;AAC1C,WAAA,0BAA0B,KAAK,CAAC,UAAU;AAC7C,oBAAY,KAAK;AACV,eAAA,QAAQ,OAAO,KAAK;AAAA,MAAA,CAC5B;AAAA,IAAA;AAAA,EACH;AAEJ;AAhFE,cADW,iBACI,uBAAiD,CAAC;AACjE,cAFW,iBAEI,+BACb,CAAC;AACH,cAJW,iBAII,6BACb,CAAC;"}