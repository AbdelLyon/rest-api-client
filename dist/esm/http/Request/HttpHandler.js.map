{"version":3,"file":"HttpHandler.js","sources":["../../../../src/http/Request/HttpHandler.ts"],"sourcesContent":["import type { FetchResult, HandlerConfig, RequestConfig, RetryOptions } from \"@/http/types\";\n\n\nexport class HttpHandler {\n   private readonly idempotentMethods = [\"GET\", \"HEAD\", \"OPTIONS\", \"PUT\", \"DELETE\"];\n   private maxRetries = 3;\n   private defaultTimeout = 10000;\n   private withCredentials = true;\n\n   configure(config: HandlerConfig): void {\n      this.maxRetries = config.maxRetries;\n      this.defaultTimeout = config.defaultTimeout;\n      this.withCredentials = config.withCredentials;\n   }\n\n   async executeRequest(\n      url: string,\n      config: RequestConfig,\n   ): Promise<Response> {\n      return this.fetchWithRetry(url, config, {\n         maxRetries: this.maxRetries,\n         defaultTimeout: this.defaultTimeout,\n         withCredentials: this.withCredentials,\n         attempt: 1,\n      });\n   }\n\n   async parseResponse<T>(response: Response): Promise<T> {\n      const contentType = response.headers.get(\"content-type\");\n\n      if (contentType?.includes(\"application/json\")) {\n         return await response.json() as T;\n      }\n\n      return await response.text() as unknown as T;\n   }\n\n   private async fetchWithRetry(\n      url: string,\n      config: RequestConfig,\n      retryOptions: RetryOptions,\n   ): Promise<Response> {\n      const { maxRetries, attempt, defaultTimeout, withCredentials } = retryOptions;\n\n      try {\n         const { response, timeoutId } = await this.performFetch(\n            url,\n            config,\n            defaultTimeout,\n            withCredentials,\n         );\n\n         clearTimeout(timeoutId);\n\n         if (!response.ok && this.shouldRetry(response.status, config.method, attempt, maxRetries)) {\n            return this.retryWithBackoff(url, config, {\n               maxRetries,\n               defaultTimeout,\n               withCredentials,\n               attempt,\n            });\n         }\n\n         return response;\n      } catch (error) {\n         if (error instanceof DOMException && error.name === \"AbortError\") {\n            throw new Error(`Request timeout after ${config.timeout || defaultTimeout}ms`);\n         }\n\n         if (attempt < maxRetries && this.isRetryableError(0, config.method)) {\n            return this.retryWithBackoff(url, config, {\n               maxRetries,\n               defaultTimeout,\n               withCredentials,\n               attempt,\n            });\n         }\n\n         throw error;\n      }\n   }\n\n   private async performFetch(\n      url: string,\n      config: RequestConfig,\n      defaultTimeout: number,\n      withCredentials: boolean,\n   ): Promise<FetchResult> {\n      const { timeout = defaultTimeout, params, data, ...fetchOptions } = config;\n\n      const fullUrl = this.appendQueryParams(url, params);\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(\"Request timeout\"), timeout);\n      const body = this.prepareRequestBody(data);\n\n      const response = await fetch(fullUrl, {\n         ...fetchOptions,\n         body,\n         signal: controller.signal,\n         credentials: withCredentials ? \"include\" : \"same-origin\",\n      });\n\n      return { response, timeoutId };\n   }\n\n   private prepareRequestBody(data: unknown): string | undefined {\n      if (data === undefined) {\n         return undefined;\n      }\n\n      return typeof data === \"string\" ? data : JSON.stringify(data);\n   }\n\n   private appendQueryParams(\n      url: string,\n      params?: Record<string, string>,\n   ): string {\n      if (!params || Object.keys(params).length === 0) {\n         return url;\n      }\n\n      const queryParams = new URLSearchParams();\n      for (const [key, value] of Object.entries(params)) {\n         queryParams.append(key, value);\n      }\n\n      return `${url}?${queryParams.toString()}`;\n   }\n\n   private isRetryableError(status: number, method?: string): boolean {\n      const isIdempotent = !method || this.idempotentMethods.includes(method.toUpperCase());\n\n      return isIdempotent && (\n         status === 0 ||\n         status === 429 ||\n         (status >= 500 && status < 600)\n      );\n   }\n\n   private shouldRetry(\n      status: number,\n      method?: string,\n      attempt?: number,\n      maxRetries?: number,\n   ): boolean {\n      return (\n         attempt !== undefined &&\n         maxRetries !== undefined &&\n         attempt < maxRetries &&\n         this.isRetryableError(status, method)\n      );\n   }\n\n   private async retryWithBackoff(\n      url: string,\n      config: RequestConfig,\n      retryOptions: RetryOptions,\n   ): Promise<Response> {\n      const { maxRetries, attempt, defaultTimeout, withCredentials } = retryOptions;\n\n      const delay = Math.pow(2, attempt) * 100;\n      await new Promise((resolve) => setTimeout(resolve, delay));\n\n      return this.fetchWithRetry(url, config, {\n         maxRetries,\n         defaultTimeout,\n         withCredentials,\n         attempt: attempt + 1,\n      });\n   }\n}"],"names":[],"mappings":"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"}