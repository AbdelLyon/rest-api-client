{"version":3,"file":"index.es.js","sources":["../src/services/HttpClient.ts","../src/services/Mutation.ts","../src/services/Query.ts"],"sourcesContent":["import type { IHttpClient } from \"@/interfaces\";\nimport type { HttpConfigOptions } from \"@/types/common\";\n\n// Erreur personnalisée pour les requêtes API\nexport class ApiRequestError extends Error {\n  status?: number;\n  data?: any;\n  config: RequestInit & { url?: string; };\n\n  constructor (error: unknown, config: RequestInit & { url?: string; }) {\n    const message = error instanceof Error ? error.message : String(error);\n    super(message);\n    this.name = \"ApiRequestError\";\n    this.config = config;\n\n    if (error && typeof error === \"object\" && \"status\" in error) {\n      this.status = (error as any).status;\n    }\n    if (error && typeof error === \"object\" && \"data\" in error) {\n      this.data = (error as any).data;\n    }\n  }\n}\n\n// Types pour les intercepteurs\ntype RequestInterceptor = (config: RequestConfig) => Promise<RequestConfig> | RequestConfig;\ntype ResponseSuccessInterceptor = (response: Response) => Promise<Response> | Response;\ntype ResponseErrorInterceptor = (error: any) => Promise<any>;\n\n// Configuration de requête étendue\nexport interface RequestConfig extends RequestInit {\n  url: string;\n  params?: Record<string, string>;\n  data?: any;\n  timeout?: number;\n}\n\nexport class HttpClient implements IHttpClient {\n  private static instances: Map<string, HttpClient> = new Map();\n  private static defaultInstanceName: string = \"default\";\n\n  // Intercepteurs statiques uniquement\n  private static requestInterceptors: RequestInterceptor[] = [];\n  private static responseSuccessInterceptors: ResponseSuccessInterceptor[] = [];\n  private static responseErrorInterceptors: ResponseErrorInterceptor[] = [];\n\n  private baseURL: string;\n  private defaultTimeout: number;\n  private defaultHeaders: Record<string, string>;\n  private withCredentials: boolean;\n  private maxRetries: number;\n\n  constructor () {\n    this.baseURL = \"\";\n    this.defaultTimeout = 10000;\n    this.defaultHeaders = {};\n    this.withCredentials = true;\n    this.maxRetries = 3;\n  }\n\n  /**\n   * Interface statique pour gérer les intercepteurs\n   */\n  public static interceptors = {\n    request: {\n      use: (interceptor: RequestInterceptor): number => {\n        return HttpClient.requestInterceptors.push(interceptor) - 1;\n      },\n      eject: (index: number): void => {\n        if (index >= 0 && index < HttpClient.requestInterceptors.length) {\n          HttpClient.requestInterceptors.splice(index, 1);\n        }\n      },\n      clear: (): void => {\n        HttpClient.requestInterceptors = [];\n      }\n    },\n    response: {\n      use: (\n        onSuccess: ResponseSuccessInterceptor,\n        onError?: ResponseErrorInterceptor\n      ): number => {\n        const successIndex = HttpClient.responseSuccessInterceptors.push(onSuccess) - 1;\n        if (onError) {\n          HttpClient.responseErrorInterceptors.push(onError);\n        }\n        return successIndex;\n      },\n      eject: (index: number): void => {\n        if (index >= 0 && index < HttpClient.responseSuccessInterceptors.length) {\n          HttpClient.responseSuccessInterceptors.splice(index, 1);\n          if (index < HttpClient.responseErrorInterceptors.length) {\n            HttpClient.responseErrorInterceptors.splice(index, 1);\n          }\n        }\n      },\n      clear: (): void => {\n        HttpClient.responseSuccessInterceptors = [];\n        HttpClient.responseErrorInterceptors = [];\n      }\n    }\n  };\n\n  /**\n   * Initialise une nouvelle instance HTTP ou renvoie une instance existante\n   */\n  static init(\n    options: HttpConfigOptions,\n    instanceName: string = \"default\",\n  ): HttpClient {\n    if (!this.instances.has(instanceName)) {\n      const instance = new HttpClient();\n      instance.configure(options);\n      this.instances.set(instanceName, instance);\n\n      // Si c'est la première instance, la définir comme instance par défaut\n      if (this.instances.size === 1) {\n        this.defaultInstanceName = instanceName;\n      }\n    }\n    return this.instances.get(instanceName)!;\n  }\n\n  /**\n   * Récupère une instance existante\n   */\n  static getInstance(instanceName?: string): HttpClient {\n    const name = instanceName || this.defaultInstanceName;\n\n    if (!this.instances.has(name)) {\n      throw new Error(\n        `Http instance '${name}' not initialized. Call Http.init() first.`,\n      );\n    }\n    return this.instances.get(name)!;\n  }\n\n  /**\n   * Définit l'instance par défaut\n   */\n  static setDefaultInstance(instanceName: string): void {\n    if (!this.instances.has(instanceName)) {\n      throw new Error(\n        `Cannot set default: Http instance '${instanceName}' not initialized.`,\n      );\n    }\n    this.defaultInstanceName = instanceName;\n  }\n\n  /**\n   * Récupère la liste des instances disponibles\n   */\n  static getAvailableInstances(): string[] {\n    return Array.from(this.instances.keys());\n  }\n\n  /**\n   * Réinitialise une instance ou toutes les instances\n   */\n  static resetInstance(instanceName?: string): void {\n    if (instanceName) {\n      this.instances.delete(instanceName);\n\n      // Si l'instance par défaut a été supprimée, réinitialiser\n      if (\n        instanceName === this.defaultInstanceName &&\n        this.instances.size > 0\n      ) {\n        this.defaultInstanceName =\n          this.instances.keys().next().value ?? \"default\";\n      }\n    } else {\n      // Réinitialiser toutes les instances\n      this.instances.clear();\n      this.defaultInstanceName = \"default\";\n    }\n  }\n\n  /**\n   * Configure l'instance HTTP\n   */\n  private configure(options: HttpConfigOptions): void {\n    // Configuration de base\n    this.baseURL = this.getFullBaseUrl(options);\n    this.defaultTimeout = options.timeout ?? 10000;\n    this.maxRetries = options.maxRetries ?? 3;\n    this.withCredentials = options.withCredentials ?? true;\n\n    // Headers par défaut\n    this.defaultHeaders = {\n      \"Content-Type\": \"application/json\",\n      \"Accept\": \"application/json\",\n      ...options.headers,\n    };\n\n    // Configuration des intercepteurs par défaut\n    this.setupDefaultInterceptors();\n  }\n\n  /**\n   * Construit l'URL de base complète\n   */\n  private getFullBaseUrl(options: HttpConfigOptions): string {\n    if (!options.baseURL) {\n      throw new Error(\"baseURL is required in HttpConfigOptions\");\n    }\n\n    let baseUrl = options.baseURL.trim();\n    if (baseUrl.endsWith(\"/\")) {\n      baseUrl = baseUrl.slice(0, -1);\n    }\n\n    if (options.apiPrefix) {\n      let prefix = options.apiPrefix.trim();\n      if (!prefix.startsWith(\"/\")) {\n        prefix = \"/\" + prefix;\n      }\n      if (prefix.endsWith(\"/\")) {\n        prefix = prefix.slice(0, -1);\n      }\n\n      return baseUrl + prefix;\n    }\n\n    if (options.apiVersion) {\n      return `${baseUrl}/v${options.apiVersion}`;\n    }\n\n    return baseUrl;\n  }\n\n  /**\n   * Configure les intercepteurs par défaut\n   */\n  private setupDefaultInterceptors(): void {\n    // Si aucun intercepteur d'erreur n'est configuré, ajouter un par défaut\n    if (HttpClient.responseErrorInterceptors.length === 0) {\n      HttpClient.interceptors.response.use(\n        (response) => response,\n        (error) => {\n          this.logError(error);\n          return Promise.reject(error);\n        }\n      );\n    }\n  }\n\n  /**\n   * Journalise les erreurs de requête\n   */\n  private logError(error: any): void {\n    const errorDetails = {\n      url: error.config?.url,\n      method: error.config?.method,\n      status: error.status,\n      data: error.data,\n      message: error.message,\n    };\n\n    console.error(\"API Request Error\", errorDetails);\n  }\n\n  /**\n   * Applique les intercepteurs de requête\n   */\n  private async applyRequestInterceptors(config: RequestConfig): Promise<RequestConfig> {\n    let interceptedConfig = { ...config };\n\n    for (const interceptor of HttpClient.requestInterceptors) {\n      interceptedConfig = await Promise.resolve(interceptor(interceptedConfig));\n    }\n\n    return interceptedConfig;\n  }\n\n  /**\n   * Applique les intercepteurs de réponse réussie\n   */\n  private async applyResponseSuccessInterceptors(response: Response): Promise<Response> {\n    let interceptedResponse = response;\n\n    for (const interceptor of HttpClient.responseSuccessInterceptors) {\n      interceptedResponse = await Promise.resolve(interceptor(interceptedResponse.clone()));\n    }\n\n    return interceptedResponse;\n  }\n\n  /**\n   * Applique les intercepteurs d'erreur de réponse\n   */\n  private async applyResponseErrorInterceptors(error: any): Promise<any> {\n    let interceptedError = error;\n\n    for (const interceptor of HttpClient.responseErrorInterceptors) {\n      try {\n        interceptedError = await Promise.resolve(interceptor(interceptedError));\n        // Si un intercepteur résout l'erreur, on arrête la chaîne\n        if (!(interceptedError instanceof Error)) {\n          return interceptedError;\n        }\n      } catch (e) {\n        interceptedError = e;\n      }\n    }\n\n    return Promise.reject(interceptedError);\n  }\n\n  /**\n   * Détermine si une erreur est susceptible d'être réessayée\n   */\n  private isRetryableError(status: number, method?: string): boolean {\n    const idempotentMethods = ['GET', 'HEAD', 'OPTIONS', 'PUT', 'DELETE'];\n    const isIdempotent = !method || idempotentMethods.includes(method.toUpperCase());\n\n    return (\n      isIdempotent && (\n        status === 0 || // Erreur réseau\n        status === 429 || // Trop de requêtes\n        (status >= 500 && status < 600) // Erreur serveur\n      )\n    );\n  }\n\n  /**\n   * Effectue une requête avec gestion des tentatives\n   */\n  private async fetchWithRetry(\n    url: string,\n    config: RequestConfig,\n    attempt: number = 1\n  ): Promise<Response> {\n    try {\n      // Préparer la configuration\n      const { timeout = this.defaultTimeout, params, data, ...fetchOptions } = config;\n      let fullUrl = url;\n\n      // Ajouter les paramètres de requête s'ils existent\n      if (params && Object.keys(params).length > 0) {\n        const queryParams = new URLSearchParams();\n        for (const [key, value] of Object.entries(params)) {\n          queryParams.append(key, value);\n        }\n        fullUrl += `?${queryParams.toString()}`;\n      }\n\n      // Configurer le timeout\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort('Request timeout'), timeout);\n\n      // Préparer le corps de la requête\n      let body: any = undefined;\n      if (data !== undefined) {\n        body = typeof data === 'string' ? data : JSON.stringify(data);\n      }\n\n      // Effectuer la requête\n      const response = await fetch(fullUrl, {\n        ...fetchOptions,\n        body,\n        signal: controller.signal,\n        credentials: this.withCredentials ? 'include' : 'same-origin',\n      });\n\n      clearTimeout(timeoutId);\n\n      // Si la réponse n'est pas OK et que la tentative est possible\n      if (!response.ok) {\n        if (\n          attempt < this.maxRetries &&\n          this.isRetryableError(response.status, config.method)\n        ) {\n          // Attente exponentielle entre les tentatives\n          const delay = Math.pow(2, attempt) * 100;\n          await new Promise(resolve => setTimeout(resolve, delay));\n          return this.fetchWithRetry(url, config, attempt + 1);\n        }\n      }\n\n      return response;\n\n    } catch (error) {\n      // Si c'est une erreur d'abandon due au timeout, convertir en erreur plus explicite\n      if (error instanceof DOMException && error.name === 'AbortError') {\n        throw new Error(`Request timeout after ${config.timeout || this.defaultTimeout}ms`);\n      }\n\n      // Si la tentative est possible pour les erreurs réseau\n      if (attempt < this.maxRetries && this.isRetryableError(0, config.method)) {\n        const delay = Math.pow(2, attempt) * 100;\n        await new Promise(resolve => setTimeout(resolve, delay));\n        return this.fetchWithRetry(url, config, attempt + 1);\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Méthode principale pour effectuer une requête\n   */\n  public async request<TResponse = any>(\n    config: Partial<RequestConfig> & { url: string; },\n    options: Partial<RequestConfig> = {},\n  ): Promise<TResponse> {\n    try {\n      const mergedConfig: RequestConfig = {\n        method: 'GET',\n        timeout: this.defaultTimeout,\n        ...config,\n        ...options,\n        headers: {\n          ...this.defaultHeaders,\n          ...(config.headers || {}),\n          ...(options.headers || {})\n        }\n      };\n\n      // Construire l'URL complète\n      const url = new URL(\n        mergedConfig.url.startsWith('http')\n          ? mergedConfig.url\n          : `${this.baseURL}${mergedConfig.url.startsWith('/') ? '' : '/'}${mergedConfig.url}`\n      ).toString();\n\n      // Appliquer les intercepteurs de requête\n      const interceptedConfig = await this.applyRequestInterceptors({\n        ...mergedConfig,\n        url\n      });\n\n      // Effectuer la requête avec gestion des tentatives\n      let response = await this.fetchWithRetry(url, interceptedConfig);\n\n      // Appliquer les intercepteurs de réponse réussie\n      response = await this.applyResponseSuccessInterceptors(response);\n\n      // Traiter la réponse selon son type\n      if (response.headers.get('content-type')?.includes('application/json')) {\n        return await response.json() as TResponse;\n      } else {\n        return await response.text() as unknown as TResponse;\n      }\n\n    } catch (error) {\n      // Créer une erreur API appropriée\n      const apiError = error instanceof ApiRequestError\n        ? error\n        : new ApiRequestError(error, {\n          ...config,\n          ...options,\n          url: config.url\n        });\n\n      // Appliquer les intercepteurs d'erreur\n      return this.applyResponseErrorInterceptors(apiError);\n    }\n  }\n}","import { z } from \"zod\";\nimport { HttpClient } from \"./HttpClient\";\nimport type { DeleteRequest, DeleteResponse } from \"../types/delete\";\nimport type { ActionRequest, ActionResponse } from \"../types/action\";\nimport type { MutationRequest, MutationResponse } from \"../types/mutate\";\nimport type { IMutation } from \"@/interfaces\";\nimport { RequestConfig } from \"@/types/common\";\n\nexport abstract class Mutation<T> implements IMutation<T> {\n  protected http: HttpClient;\n  protected pathname: string;\n  protected schema: z.ZodType<T>;\n\n  constructor (pathname: string, schema: z.ZodType<T>) {\n    this.http = HttpClient.getInstance();\n    this.pathname = pathname;\n    this.schema = schema;\n  }\n\n  private validateData(data: unknown[]): T[] {\n    return data.map((item) => {\n      const result = this.schema.safeParse(item);\n      if (!result.success) {\n        console.error(\"Type validation failed:\", result.error.errors);\n        throw new Error(\n          `Type validation failed: ${JSON.stringify(result.error.errors)}`,\n        );\n      }\n      return result.data;\n    });\n  }\n\n  public async mutate<TAttributes, TRelations>(\n    mutateRequest: MutationRequest<TAttributes, TRelations>,\n    options: Partial<RequestConfig> = {},\n  ): Promise<MutationResponse<T>> {\n    const response = await this.http.request<MutationResponse<T>>(\n      {\n        method: \"POST\",\n        url: `${this.pathname}/mutate`,\n        data: mutateRequest,\n      },\n      options,\n    );\n\n    return {\n      ...response,\n      data: this.validateData(response.data),\n    };\n  }\n\n  public executeAction(\n    actionRequest: ActionRequest,\n    options: Partial<RequestConfig> = {},\n  ): Promise<ActionResponse> {\n    return this.http.request<ActionResponse>(\n      {\n        method: \"POST\",\n        url: `${this.pathname}/actions/${actionRequest.action}`,\n        data: actionRequest.payload,\n      },\n      options,\n    );\n  }\n\n  public async delete(\n    request: DeleteRequest,\n    options: Partial<RequestConfig> = {},\n  ): Promise<DeleteResponse<T>> {\n    const response = await this.http.request<DeleteResponse<T>>(\n      {\n        method: \"DELETE\",\n        url: this.pathname,\n        data: request,\n      },\n      options,\n    );\n\n    return {\n      ...response,\n      data: this.validateData(response.data),\n    };\n  }\n\n  public async forceDelete(\n    request: DeleteRequest,\n    options: Partial<RequestConfig> = {},\n  ): Promise<DeleteResponse<T>> {\n    const response = await this.http.request<DeleteResponse<T>>(\n      {\n        method: \"DELETE\",\n        url: `${this.pathname}/force`,\n        data: request,\n      },\n      options,\n    );\n\n    return {\n      ...response,\n      data: this.validateData(response.data),\n    };\n  }\n\n  public async restore(\n    request: DeleteRequest,\n    options: Partial<RequestConfig> = {},\n  ): Promise<DeleteResponse<T>> {\n    const response = await this.http.request<DeleteResponse<T>>(\n      {\n        method: \"POST\",\n        url: `${this.pathname}/restore`,\n        data: request,\n      },\n      options,\n    );\n\n    return {\n      ...response,\n      data: this.validateData(response.data),\n    };\n  }\n}\n","import { z } from \"zod\";\nimport { HttpClient } from \"./HttpClient\";\nimport type { DetailsResponse, SearchRequest, SearchResponse } from \"../types\";\nimport type { IQuery } from \"@/interfaces\";\nimport { PaginatedSearchRequest } from \"@/types/search\";\nimport { RequestConfig } from \"@/types/common\";\n\nexport abstract class Query<T> implements IQuery<T> {\n  protected http: HttpClient;\n  protected pathname: string;\n  protected schema: z.ZodType<T>;\n\n  constructor (pathname: string, schema: z.ZodType<T>) {\n    this.http = HttpClient.getInstance();\n    this.pathname = pathname;\n    this.schema = schema;\n  }\n\n  private validateData(data: unknown[]): T[] {\n    return data.map((item) => {\n      const result = this.schema.safeParse(item);\n      if (!result.success) {\n        console.error(\"Type validation failed:\", result.error.errors);\n        throw new Error(\n          `Type validation failed: ${JSON.stringify(result.error.errors)}`,\n        );\n      }\n      return result.data;\n    });\n  }\n\n  private searchRequest(\n    search: SearchRequest,\n    options: Partial<RequestConfig> = {},\n  ): Promise<SearchResponse<T>> {\n    return this.http.request<SearchResponse<T>>(\n      {\n        method: \"POST\",\n        url: `${this.pathname}/search`,\n        data: { search },\n      },\n      options,\n    );\n  }\n\n  public async search(\n    search: SearchRequest,\n    options: Partial<RequestConfig> = {},\n  ): Promise<Array<T>> {\n    const response = await this.searchRequest(search, options);\n    return this.validateData(response.data);\n  }\n\n  public async searchPaginate(\n    search: PaginatedSearchRequest,\n    options: Partial<RequestConfig> = {},\n  ): Promise<SearchResponse<T>> {\n    const response = await this.searchRequest(search, options);\n\n    return {\n      ...response,\n      data: this.validateData(response.data),\n    };\n  }\n\n  public getdetails(\n    options: Partial<RequestConfig> = {},\n  ): Promise<DetailsResponse> {\n    return this.http.request<DetailsResponse>(\n      {\n        method: \"GET\",\n        url: this.pathname,\n      },\n      options,\n    );\n  }\n}\n"],"names":["ApiRequestError","error","config","message","__publicField","_HttpClient","options","instanceName","instance","name","baseUrl","prefix","response","_a","_b","errorDetails","interceptedConfig","interceptor","interceptedResponse","interceptedError","e","status","method","url","attempt","timeout","params","data","fetchOptions","fullUrl","queryParams","key","value","controller","timeoutId","body","delay","resolve","mergedConfig","apiError","index","onSuccess","onError","successIndex","HttpClient","Mutation","pathname","schema","item","result","mutateRequest","actionRequest","request","Query","search"],"mappings":"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"}