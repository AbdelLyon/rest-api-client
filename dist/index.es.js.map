{"version":3,"file":"index.es.js","sources":["../src/services/ApiRequestError.ts","../src/services/HttpClient.ts","../src/services/MutateRequestBuilder.ts","../src/services/Mutation.ts","../src/services/Query.ts","../src/services/Auth.ts"],"sourcesContent":["import type { ApiErrorSource, RequestConfig } from \"@/types/common\";\n\n\nexport class ApiRequestError extends Error {\n  status?: number;\n  statusText?: string;\n  data?: unknown;\n  originalError: unknown;\n  requestConfig: RequestConfig;\n\n  constructor (error: unknown, requestConfig: RequestConfig) {\n    const message = error instanceof Error\n      ? error.message\n      : \"API Service Request Failed\";\n\n    super(message);\n    this.name = \"ApiRequestError\";\n    this.originalError = error;\n    this.requestConfig = requestConfig;\n\n    if (error && typeof error === \"object\") {\n      const errorObj = error as ApiErrorSource;\n\n      if (\"status\" in errorObj) {\n        this.status = errorObj.status;\n      }\n      if (\"statusText\" in errorObj) {\n        this.statusText = errorObj.statusText as string;\n      }\n      if (\"data\" in errorObj) {\n        this.data = errorObj.data;\n      }\n      // Si c'est une erreur de fetch (Response)\n      if (\"response\" in errorObj && errorObj.response instanceof Response) {\n        const response = errorObj.response;\n        this.status = response.status;\n        this.statusText = response.statusText;\n      }\n    }\n\n    // Capturer la stack trace\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ApiRequestError);\n    }\n  }\n\n  // Méthodes utilitaires pour vérifier le type d'erreur\n  isNotFound(): boolean {\n    return this.status === 404;\n  }\n\n  isUnauthorized(): boolean {\n    return this.status === 401;\n  }\n\n  isForbidden(): boolean {\n    return this.status === 403;\n  }\n\n  isServerError(): boolean {\n    return this.status !== undefined && this.status >= 500 && this.status < 600;\n  }\n\n  isNetworkError(): boolean {\n    return this.status === undefined || this.status === 0;\n  }\n}","import type { IHttpClient } from \"@/interfaces\";\nimport type { HttpConfig, HttpConfigOptions, RequestConfig, RequestInterceptor, ResponseErrorInterceptor, ResponseSuccessInterceptor } from \"@/types/common\";\nimport { ApiRequestError } from \"./ApiRequestError\";\n\nexport class HttpClient implements IHttpClient {\n  private static instances: Map<string, HttpClient> = new Map();\n  private static defaultInstanceName: string;\n\n  // Intercepteurs statiques\n  private static requestInterceptors: RequestInterceptor[] = [];\n  private static responseSuccessInterceptors: ResponseSuccessInterceptor[] = [];\n  private static responseErrorInterceptors: ResponseErrorInterceptor[] = [];\n\n  private baseURL: string;\n  private defaultTimeout: number;\n  private defaultHeaders: Record<string, string>;\n  private withCredentials: boolean;\n  private maxRetries: number;\n\n  private constructor () {\n    this.baseURL = \"\";\n    this.defaultTimeout = 10000;\n    this.defaultHeaders = {};\n    this.withCredentials = true;\n    this.maxRetries = 3;\n  }\n\n  /**\n   * Initialise une nouvelle instance HTTP avec intercepteurs\n   */\n  static init(config: {\n    httpConfig: HttpConfig;\n    instanceName: string;\n  }): HttpClient {\n    const { httpConfig, instanceName } = config;\n\n    HttpClient.requestInterceptors = [\n      ...HttpClient.requestInterceptors,\n      ...(httpConfig.interceptors?.request ?? [])\n    ];\n\n    if (httpConfig.interceptors?.response) {\n      HttpClient.responseSuccessInterceptors = [\n        ...HttpClient.responseSuccessInterceptors,\n        ...(httpConfig.interceptors.response.success ?? [])\n      ];\n\n      HttpClient.responseErrorInterceptors = [\n        ...HttpClient.responseErrorInterceptors,\n        ...(httpConfig.interceptors.response.error ?? [])\n      ];\n    }\n\n    // Créer ou récupérer l'instance\n    if (!this.instances.has(instanceName)) {\n      const instance = new HttpClient();\n      instance.configure(httpConfig);\n      this.instances.set(instanceName, instance);\n\n      // Si c'est la première instance, la définir comme instance par défaut\n      if (this.instances.size === 1) {\n        this.defaultInstanceName = instanceName;\n      }\n    }\n    return this.instances.get(instanceName)!;\n  }\n\n  /**\n   * Récupère une instance existante\n   */\n  static getInstance(instanceName?: string): HttpClient {\n    const name = instanceName || this.defaultInstanceName;\n\n    if (!this.instances.has(name)) {\n      throw new Error(\n        `Http instance '${name}' not initialized. Call Http.init() first.`,\n      );\n    }\n    return this.instances.get(name)!;\n  }\n\n  /**\n   * Définit l'instance par défaut\n   */\n  static setDefaultInstance(instanceName: string): void {\n    if (!this.instances.has(instanceName)) {\n      throw new Error(\n        `Cannot set default: Http instance '${instanceName}' not initialized.`,\n      );\n    }\n    this.defaultInstanceName = instanceName;\n  }\n\n  /**\n   * Récupère la liste des instances disponibles\n   */\n  static getAvailableInstances(): string[] {\n    return Array.from(this.instances.keys());\n  }\n\n  /**\n   * Réinitialise une instance ou toutes les instances\n   */\n  static resetInstance(instanceName?: string): void {\n    if (instanceName) {\n      this.instances.delete(instanceName);\n\n      // Si l'instance par défaut a été supprimée, réinitialiser\n      if (\n        instanceName === this.defaultInstanceName &&\n        this.instances.size > 0\n      ) {\n        this.defaultInstanceName =\n          this.instances.keys().next().value ?? \"default\";\n      }\n    } else {\n      // Réinitialiser toutes les instances\n      this.instances.clear();\n      this.defaultInstanceName = \"default\";\n    }\n  }\n\n  /**\n   * Configure l'instance HTTP\n   */\n  private configure(options: HttpConfigOptions): void {\n    // Configuration de base\n    this.baseURL = this.getFullBaseUrl(options);\n    this.defaultTimeout = options.timeout ?? 10000;\n    this.maxRetries = options.maxRetries ?? 3;\n    this.withCredentials = options.withCredentials ?? true;\n\n    // Headers par défaut\n    this.defaultHeaders = {\n      \"Content-Type\": \"application/json\",\n      \"Accept\": \"application/json\",\n      ...options.headers,\n    };\n\n    // Configuration des intercepteurs par défaut\n    this.setupDefaultInterceptors();\n  }\n\n  /**\n   * Construit l'URL de base complète\n   */\n  private getFullBaseUrl(options: HttpConfigOptions): string {\n    if (!options.baseURL) {\n      throw new Error(\"baseURL is required in HttpConfigOptions\");\n    }\n\n    let baseUrl = options.baseURL.trim();\n    if (baseUrl.endsWith(\"/\")) {\n      baseUrl = baseUrl.slice(0, -1);\n    }\n\n    if (options.apiPrefix) {\n      let prefix = options.apiPrefix.trim();\n      if (!prefix.startsWith(\"/\")) {\n        prefix = \"/\" + prefix;\n      }\n      if (prefix.endsWith(\"/\")) {\n        prefix = prefix.slice(0, -1);\n      }\n\n      return baseUrl + prefix;\n    }\n\n    if (options.apiVersion) {\n      return `${baseUrl}/v${options.apiVersion}`;\n    }\n\n    return baseUrl;\n  }\n\n  /**\n   * Configure les intercepteurs par défaut\n   */\n  private setupDefaultInterceptors(): void {\n    // Ajouter un intercepteur d'erreur par défaut si aucun n'est configuré\n    if (HttpClient.responseErrorInterceptors.length === 0) {\n      HttpClient.responseErrorInterceptors.push((error) => {\n        this.logError(error);\n        return Promise.reject(error);\n      });\n    }\n  }\n\n  /**\n   * Journalise les erreurs de requête\n   */\n  private logError(error: any): void {\n    const errorDetails = {\n      url: error.config?.url,\n      method: error.config?.method,\n      status: error.status,\n      data: error.data,\n      message: error.message,\n    };\n\n    console.error(\"API Request Error\", errorDetails);\n  }\n\n  /**\n   * Applique les intercepteurs de requête\n   */\n  private async applyRequestInterceptors(config: RequestConfig): Promise<RequestConfig> {\n    let interceptedConfig = { ...config };\n\n    for (const interceptor of HttpClient.requestInterceptors) {\n      interceptedConfig = await Promise.resolve(interceptor(interceptedConfig));\n    }\n\n    return interceptedConfig;\n  }\n\n  /**\n   * Applique les intercepteurs de réponse réussie\n   */\n  private async applyResponseSuccessInterceptors(response: Response): Promise<Response> {\n    let interceptedResponse = response;\n\n    for (const interceptor of HttpClient.responseSuccessInterceptors) {\n      interceptedResponse = await Promise.resolve(interceptor(interceptedResponse.clone()));\n    }\n\n    return interceptedResponse;\n  }\n\n  /**\n   * Applique les intercepteurs d'erreur de réponse\n   */\n  private async applyResponseErrorInterceptors(error: any): Promise<any> {\n    let interceptedError = error;\n\n    for (const interceptor of HttpClient.responseErrorInterceptors) {\n      try {\n        interceptedError = await Promise.resolve(interceptor(interceptedError));\n        // Si un intercepteur résout l'erreur, on arrête la chaîne\n        if (!(interceptedError instanceof Error)) {\n          return interceptedError;\n        }\n      } catch (e) {\n        interceptedError = e;\n      }\n    }\n\n    return Promise.reject(interceptedError);\n  }\n\n  /**\n   * Détermine si une erreur est susceptible d'être réessayée\n   */\n  private isRetryableError(status: number, method?: string): boolean {\n    const idempotentMethods = ['GET', 'HEAD', 'OPTIONS', 'PUT', 'DELETE'];\n    const isIdempotent = !method || idempotentMethods.includes(method.toUpperCase());\n\n    return (\n      isIdempotent && (\n        status === 0 || // Erreur réseau\n        status === 429 || // Trop de requêtes\n        (status >= 500 && status < 600) // Erreur serveur\n      )\n    );\n  }\n\n  /**\n   * Effectue une requête avec gestion des tentatives\n   */\n  private async fetchWithRetry(\n    url: string,\n    config: RequestConfig,\n    attempt: number = 1\n  ): Promise<Response> {\n    try {\n      // Préparer la configuration\n      const { timeout = this.defaultTimeout, params, data, ...fetchOptions } = config;\n      let fullUrl = url;\n\n      // Ajouter les paramètres de requête s'ils existent\n      if (params && Object.keys(params).length > 0) {\n        const queryParams = new URLSearchParams();\n        for (const [key, value] of Object.entries(params)) {\n          queryParams.append(key, value);\n        }\n        fullUrl += `?${queryParams.toString()}`;\n      }\n\n      // Configurer le timeout\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort('Request timeout'), timeout);\n\n      // Préparer le corps de la requête\n      let body: any = undefined;\n      if (data !== undefined) {\n        body = typeof data === 'string' ? data : JSON.stringify(data);\n      }\n\n      // Effectuer la requête\n      const response = await fetch(fullUrl, {\n        ...fetchOptions,\n        body,\n        signal: controller.signal,\n        credentials: this.withCredentials ? 'include' : 'same-origin',\n      });\n\n      clearTimeout(timeoutId);\n\n      // Si la réponse n'est pas OK et que la tentative est possible\n      if (!response.ok) {\n        if (\n          attempt < this.maxRetries &&\n          this.isRetryableError(response.status, config.method)\n        ) {\n          // Attente exponentielle entre les tentatives\n          const delay = Math.pow(2, attempt) * 100;\n          await new Promise(resolve => setTimeout(resolve, delay));\n          return this.fetchWithRetry(url, config, attempt + 1);\n        }\n      }\n\n      return response;\n\n    } catch (error) {\n      // Si c'est une erreur d'abandon due au timeout, convertir en erreur plus explicite\n      if (error instanceof DOMException && error.name === 'AbortError') {\n        throw new Error(`Request timeout after ${config.timeout || this.defaultTimeout}ms`);\n      }\n\n      // Si la tentative est possible pour les erreurs réseau\n      if (attempt < this.maxRetries && this.isRetryableError(0, config.method)) {\n        const delay = Math.pow(2, attempt) * 100;\n        await new Promise(resolve => setTimeout(resolve, delay));\n        return this.fetchWithRetry(url, config, attempt + 1);\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Méthode principale pour effectuer une requête\n   */\n  public async request<TResponse = any>(\n    config: Partial<RequestConfig> & { url: string; },\n    options: Partial<RequestConfig> = {},\n  ): Promise<TResponse> {\n    try {\n      const mergedConfig: RequestConfig = {\n        method: 'GET',\n        timeout: this.defaultTimeout,\n        ...config,\n        ...options,\n        headers: {\n          ...this.defaultHeaders,\n          ...(config.headers || {}),\n          ...(options.headers || {})\n        }\n      };\n\n      // Construire l'URL complète\n      const url = new URL(\n        mergedConfig.url.startsWith('http')\n          ? mergedConfig.url\n          : `${this.baseURL}${mergedConfig.url.startsWith('/') ? '' : '/'}${mergedConfig.url}`\n      ).toString();\n\n      // Appliquer les intercepteurs de requête\n      const interceptedConfig = await this.applyRequestInterceptors({\n        ...mergedConfig,\n        url\n      });\n\n      // Effectuer la requête avec gestion des tentatives\n      let response = await this.fetchWithRetry(url, interceptedConfig);\n\n      // Appliquer les intercepteurs de réponse réussie\n      response = await this.applyResponseSuccessInterceptors(response);\n\n      // Traiter la réponse selon son type\n      if (response.headers.get('content-type')?.includes('application/json')) {\n        return await response.json() as TResponse;\n      } else {\n        return await response.text() as unknown as TResponse;\n      }\n\n    } catch (error) {\n      // Créer une erreur API appropriée\n      const apiError = error instanceof ApiRequestError\n        ? error\n        : new ApiRequestError(error, {\n          ...config,\n          ...options,\n          url: config.url\n        });\n\n      // Appliquer les intercepteurs d'erreur\n      return this.applyResponseErrorInterceptors(apiError);\n    }\n  }\n}","// MutateRequestBuilder.ts\nimport {\n   AttachRelationDefinition,\n   DetachRelationDefinition,\n   SyncRelationDefinition,\n   ToggleRelationDefinition,\n   MutationResponse\n} from \"@/types/mutate\";\nimport { RequestConfig } from \"@/types/common\";\n\ntype ExtractModelAttributes<T> = Omit<T, 'relations'>;\n\n// Type de relation avec paramètre générique pour le type des relations\ntype RelationDefinition<T = unknown, R = unknown> =\n   | { operation: \"create\"; attributes: T; relations?: Record<string, RelationDefinition<R, unknown>>; __relationDefinition?: true; }\n   | { operation: \"update\"; key: string | number; attributes: T; relations?: Record<string, RelationDefinition<R, unknown>>; __relationDefinition?: true; }\n   | AttachRelationDefinition\n   | DetachRelationDefinition\n   | SyncRelationDefinition<T>\n   | ToggleRelationDefinition<T>;\n\n// Type plus précis pour les opérations de mutation avec relations typées\ntype TypedMutationOperation<TModel, TRelations = {}> = {\n   operation: \"create\" | \"update\";\n   key?: string | number;\n   attributes: ExtractModelAttributes<TModel>;\n   relations: TRelations;\n};\n\ntype MutationRequest<TModel, TRelations = {}> = {\n   mutate: Array<TypedMutationOperation<TModel, TRelations>>;\n};\n\n\n// Interface pour la fonction de mutation\nexport interface MutationFunction {\n   (data: any, options?: Partial<RequestConfig>): Promise<MutationResponse>;\n}\n\n// Interface qui expose uniquement build() et mutate() avec relations typées\nexport interface BuildOnly<TModel, TRelations = {}> {\n   build(): MutationRequest<TModel, TRelations>;\n   mutate(options?: Partial<RequestConfig>): Promise<MutationResponse>;\n}\n\n// Interface complète pour le builder initial\nexport interface IBuilder<TModel> {\n   build(): MutationRequest<TModel, {}>;\n\n   createEntity<T extends Record<string, unknown>, RelationKeys extends keyof T = never>(\n      attributes: T\n   ): BuildOnly<TModel, Pick<T, Extract<RelationKeys, string>>>;\n\n   updateEntity<T extends Record<string, unknown>>(\n      key: string | number,\n      attributes: T\n   ): IBuilder<TModel>;\n\n   createRelation<T, R = unknown>(\n      attributes: T,\n      relations?: Record<string, RelationDefinition<R, unknown>>\n   ): T & {\n      operation: \"create\";\n      attributes: T;\n      relations?: Record<string, RelationDefinition<R, unknown>>;\n      __relationDefinition?: true;\n   };\n\n   updateRelation<T, R = unknown>(\n      key: string | number,\n      attributes: T,\n      relations?: Record<string, RelationDefinition<R, unknown>>\n   ): T & {\n      operation: \"update\";\n      key: string | number;\n      attributes: T;\n      relations?: Record<string, RelationDefinition<R, unknown>>;\n      __relationDefinition?: true;\n   };\n\n   attach(key: string | number): AttachRelationDefinition;\n   detach(key: string | number): DetachRelationDefinition;\n\n   sync<T>(\n      key: string | number | Array<string | number>,\n      attributes?: T,\n      pivot?: Record<string, string | number>,\n      withoutDetaching?: boolean\n   ): SyncRelationDefinition<T>;\n\n   toggle<T>(\n      key: string | number | Array<string | number>,\n      attributes?: T,\n      pivot?: Record<string, string | number>\n   ): ToggleRelationDefinition<T>;\n\n   // Méthode pour injecter la fonction de mutation\n   setMutationFunction(fn: MutationFunction): void;\n}\n\nexport class Builder<TModel> implements IBuilder<TModel>, BuildOnly<TModel> {\n   private static instance: Builder<unknown>;\n   private operations: Array<TypedMutationOperation<TModel, any>> = [];\n   private mutationFn: MutationFunction | null = null;\n\n   private constructor () { }\n\n   public static createBuilder<T>(): IBuilder<T> {\n      if (!Builder.instance) {\n         Builder.instance = new Builder<T>();\n      }\n      return Builder.instance as IBuilder<T>;\n   }\n\n   // Méthode pour définir la fonction de mutation\n   public setMutationFunction(fn: MutationFunction): void {\n      this.mutationFn = fn;\n   }\n\n   /**\n    * Crée une entité avec les attributs donnés, y compris des relations imbriquées\n    * @param attributes Les attributs de l'entité, pouvant contenir des relations\n    */\n   public createEntity<T extends Record<string, unknown>, RelationKeys extends keyof T = never>(\n      attributes: T\n   ): BuildOnly<TModel, Pick<T, Extract<RelationKeys, string>>> {\n      // Séparer les attributs normaux des attributs de relation\n      const normalAttributes: Record<string, unknown> = {};\n      const relations: Record<string, unknown> = {};\n\n      // Parcourir tous les attributs pour identifier les relations\n      for (const [key, value] of Object.entries(attributes)) {\n         // Vérifier si l'attribut est une relation (a une propriété 'operation')\n         if (value && typeof value === 'object' && 'operation' in value) {\n            relations[key] = value;\n         } else {\n            normalAttributes[key] = value;\n         }\n      }\n\n      const operation: TypedMutationOperation<TModel, typeof relations> = {\n         operation: \"create\",\n         attributes: normalAttributes as ExtractModelAttributes<TModel>,\n         relations\n      };\n\n      this.operations.push(operation);\n      return this as unknown as BuildOnly<TModel, Pick<T, Extract<RelationKeys, string>>>;\n   }\n\n   /**\n    * Met à jour une entité avec les attributs donnés, y compris des relations imbriquées\n    * @param key La clé de l'entité à mettre à jour\n    * @param attributes Les attributs de l'entité, pouvant contenir des relations\n    */\n   public updateEntity<T extends Record<string, unknown>>(\n      key: string | number,\n      attributes: T\n   ): IBuilder<TModel> {\n      // Séparer les attributs normaux des attributs de relation\n      const normalAttributes: Record<string, unknown> = {};\n      const relations: Record<string, unknown> = {};\n\n      for (const [attrKey, value] of Object.entries(attributes)) {\n         if (value && typeof value === 'object' && 'operation' in value) {\n            relations[attrKey] = value;\n         } else {\n            normalAttributes[attrKey] = value;\n         }\n      }\n\n      const operation: TypedMutationOperation<TModel, typeof relations> = {\n         operation: \"update\",\n         key,\n         attributes: normalAttributes as ExtractModelAttributes<TModel>,\n         relations\n      };\n\n      this.operations.push(operation);\n      return this;\n   }\n\n   /**\n    * Crée une relation avec des attributs donnés et des relations optionnelles.\n    * @param attributes Les attributs de la relation\n    * @param relations Les relations imbriquées explicites (optionnel)\n    */\n   public createRelation<T, R = unknown>(\n      attributes: T,\n      relations?: Record<string, RelationDefinition<R, unknown>>\n   ): T & {\n      operation: \"create\";\n      attributes: T;\n      relations?: Record<string, RelationDefinition<R, unknown>>;\n      __relationDefinition?: true;\n   } {\n      // Séparer les attributs normaux des attributs de relation pour les relations imbriquées\n      const normalAttributes: Record<string, unknown> = {};\n      const nestedRelations: Record<string, RelationDefinition<R, unknown>> = {};\n\n      // Extraire les relations des attributs si elles ne sont pas fournies explicitement\n      if (!relations && attributes && typeof attributes === 'object') {\n         for (const [key, value] of Object.entries(attributes as Record<string, unknown>)) {\n            if (value && typeof value === 'object' && 'operation' in value) {\n               nestedRelations[key] = value as RelationDefinition<R, unknown>;\n            } else {\n               normalAttributes[key] = value;\n            }\n         }\n      } else if (attributes && typeof attributes === 'object') {\n         // Si des relations sont fournies explicitement, extraire seulement les attributs normaux\n         for (const [key, value] of Object.entries(attributes as Record<string, unknown>)) {\n            if (!(value && typeof value === 'object' && 'operation' in value)) {\n               normalAttributes[key] = value;\n            }\n         }\n      }\n\n      // Créer un objet qui est à la fois une relation et correspond au type T\n      const relationDefinition = {\n         operation: \"create\",\n         attributes: normalAttributes as T,\n         // Utiliser les relations explicites si fournies, sinon utiliser celles extraites des attributs\n         ...(relations ? { relations } : (Object.keys(nestedRelations).length > 0 ? { relations: nestedRelations } : {})),\n         __relationDefinition: true\n      } as T & {\n         operation: \"create\";\n         attributes: T;\n         relations?: Record<string, RelationDefinition<R, unknown>>;\n         __relationDefinition?: true;\n      };\n\n      // Pour les propriétés de l'objet original, créer des getters qui renvoient les valeurs\n      // depuis attributes pour que l'objet relation se comporte comme l'objet original\n      if (attributes && typeof attributes === 'object') {\n         for (const key of Object.keys(normalAttributes)) {\n            Object.defineProperty(relationDefinition, key, {\n               get() {\n                  return normalAttributes[key];\n               },\n               enumerable: true\n            });\n         }\n      }\n\n      return relationDefinition;\n   }\n\n   /**\n    * Met à jour une relation avec des attributs donnés et des relations optionnelles.\n    * @param key La clé de la relation à mettre à jour\n    * @param attributes Les attributs de la relation\n    * @param relations Les relations imbriquées explicites (optionnel)\n    */\n   public updateRelation<T, R = unknown>(\n      key: string | number,\n      attributes: T,\n      relations?: Record<string, RelationDefinition<R, unknown>>\n   ): T & {\n      operation: \"update\";\n      key: string | number;\n      attributes: T;\n      relations?: Record<string, RelationDefinition<R, unknown>>;\n      __relationDefinition?: true;\n   } {\n      // Séparer les attributs normaux des attributs de relation pour les relations imbriquées\n      const normalAttributes: Record<string, unknown> = {};\n      const nestedRelations: Record<string, RelationDefinition<R, unknown>> = {};\n\n      // Extraire les relations des attributs si elles ne sont pas fournies explicitement\n      if (!relations && attributes && typeof attributes === 'object') {\n         for (const [attrKey, value] of Object.entries(attributes as Record<string, unknown>)) {\n            if (value && typeof value === 'object' && 'operation' in value) {\n               nestedRelations[attrKey] = value as RelationDefinition<R, unknown>;\n            } else {\n               normalAttributes[attrKey] = value;\n            }\n         }\n      } else if (attributes && typeof attributes === 'object') {\n         // Si des relations sont fournies explicitement, extraire seulement les attributs normaux\n         for (const [attrKey, value] of Object.entries(attributes as Record<string, unknown>)) {\n            if (!(value && typeof value === 'object' && 'operation' in value)) {\n               normalAttributes[attrKey] = value;\n            }\n         }\n      }\n\n      const relationDefinition = {\n         operation: \"update\",\n         key,\n         attributes: normalAttributes as T,\n         // Utiliser les relations explicites si fournies, sinon utiliser celles extraites des attributs\n         ...(relations ? { relations } : (Object.keys(nestedRelations).length > 0 ? { relations: nestedRelations } : {})),\n         __relationDefinition: true\n      } as T & {\n         operation: \"update\";\n         key: string | number;\n         attributes: T;\n         relations?: Record<string, RelationDefinition<R, unknown>>;\n         __relationDefinition?: true;\n      };\n\n      // Même approche avec les getters\n      if (attributes && typeof attributes === 'object') {\n         for (const key of Object.keys(normalAttributes)) {\n            Object.defineProperty(relationDefinition, key, {\n               get() {\n                  return normalAttributes[key];\n               },\n               enumerable: true\n            });\n         }\n      }\n\n      return relationDefinition;\n   }\n\n   public attach(key: string | number): AttachRelationDefinition {\n      return {\n         operation: \"attach\",\n         key\n      };\n   }\n\n   public detach(key: string | number): DetachRelationDefinition {\n      return {\n         operation: \"detach\",\n         key\n      };\n   }\n\n   public sync<T>(\n      key: string | number | Array<string | number>,\n      attributes?: T,\n      pivot?: Record<string, string | number>,\n      withoutDetaching?: boolean\n   ): SyncRelationDefinition<T> {\n      return {\n         operation: \"sync\",\n         key,\n         without_detaching: withoutDetaching,\n         ...(attributes && { attributes }),\n         ...(pivot && { pivot })\n      };\n   }\n\n   public toggle<T>(\n      key: string | number | Array<string | number>,\n      attributes?: T,\n      pivot?: Record<string, string | number>\n   ): ToggleRelationDefinition<T> {\n      return {\n         operation: \"toggle\",\n         key,\n         ...(attributes && { attributes }),\n         ...(pivot && { pivot })\n      };\n   }\n\n   public build(): MutationRequest<TModel, any> {\n      const result = [...this.operations];\n      this.operations = []; // Réinitialiser le builder\n      return { mutate: result };\n   }\n\n\n   public async mutate(options?: Partial<RequestConfig>): Promise<MutationResponse> {\n      if (!this.mutationFn) {\n         throw new Error(\"Mutation function not provided to builder\");\n      }\n\n      const data = this.build();\n      return this.mutationFn(data, options);\n   }\n}","// Mutation.ts\nimport { z } from \"zod\";\nimport { HttpClient } from \"./HttpClient\";\nimport type { DeleteRequest, DeleteResponse } from \"@/types/delete\";\nimport type { ActionRequest, ActionResponse } from \"@/types/action\";\nimport type { MutationResponse } from \"@/types/mutate\";\nimport type { IMutation } from \"@/interfaces\";\nimport type { RequestConfig } from \"@/types/common\";\nimport { Builder, BuildOnly, IBuilder } from \"./MutateRequestBuilder\";\n\nexport abstract class Mutation<T> implements IMutation<T> {\n  protected http: HttpClient;\n  public builder: IBuilder<T>;\n\n  protected pathname: string;\n  protected schema: z.ZodType<T>;\n\n  constructor (pathname: string, schema: z.ZodType<T>) {\n    this.http = HttpClient.getInstance();\n    this.builder = Builder.createBuilder<T>();\n\n    // Injecter la fonction de mutation sans créer de référence circulaire\n    this.builder.setMutationFunction((data, options) => this.mutate(data, options));\n\n    this.pathname = pathname;\n    this.schema = schema;\n  }\n\n  private validateData(data: unknown[]): T[] {\n    return data.map((item) => {\n      const result = this.schema.safeParse(item);\n      if (!result.success) {\n        console.error(\"Type validation failed:\", result.error.errors);\n        throw new Error(\n          `Type validation failed: ${JSON.stringify(result.error.errors)}`,\n        );\n      }\n      return result.data;\n    });\n  }\n\n  public async mutate(\n    mutateRequest: BuildOnly<T>,\n    options?: Partial<RequestConfig>\n  ): Promise<MutationResponse> {\n    const data = 'build' in mutateRequest ? mutateRequest.build() : mutateRequest;\n\n    const response = await this.http.request<MutationResponse>(\n      {\n        method: \"POST\",\n        url: `${this.pathname}/mutate`,\n        data,\n      },\n      options,\n    );\n\n    return response;\n  }\n\n  public executeAction(\n    actionRequest: ActionRequest,\n    options: Partial<RequestConfig> = {},\n  ): Promise<ActionResponse> {\n    return this.http.request<ActionResponse>(\n      {\n        method: \"POST\",\n        url: `${this.pathname}/actions/${actionRequest.action}`,\n        data: actionRequest.payload,\n      },\n      options,\n    );\n  }\n\n  public async delete(\n    request: DeleteRequest,\n    options: Partial<RequestConfig> = {},\n  ): Promise<DeleteResponse<T>> {\n    const response = await this.http.request<DeleteResponse<T>>(\n      {\n        method: \"DELETE\",\n        url: this.pathname,\n        data: request,\n      },\n      options,\n    );\n\n    return {\n      ...response,\n      data: this.validateData(response.data),\n    };\n  }\n\n  public async forceDelete(\n    request: DeleteRequest,\n    options: Partial<RequestConfig> = {},\n  ): Promise<DeleteResponse<T>> {\n    const response = await this.http.request<DeleteResponse<T>>(\n      {\n        method: \"DELETE\",\n        url: `${this.pathname}/force`,\n        data: request,\n      },\n      options,\n    );\n\n    return {\n      ...response,\n      data: this.validateData(response.data),\n    };\n  }\n\n  public async restore(\n    request: DeleteRequest,\n    options: Partial<RequestConfig> = {},\n  ): Promise<DeleteResponse<T>> {\n    const response = await this.http.request<DeleteResponse<T>>(\n      {\n        method: \"POST\",\n        url: `${this.pathname}/restore`,\n        data: request,\n      },\n      options,\n    );\n\n    return {\n      ...response,\n      data: this.validateData(response.data),\n    };\n  }\n}","import { z } from \"zod\";\nimport { HttpClient } from \"./HttpClient\";\nimport type { DetailsResponse, SearchRequest, SearchResponse } from \"@/types\";\nimport type { IQuery } from \"@/interfaces\";\nimport type { PaginatedSearchRequest } from \"@/types/search\";\nimport type { RequestConfig } from \"@/types/common\";\n\nexport abstract class Query<T> implements IQuery<T> {\n  protected http: HttpClient;\n  protected pathname: string;\n  protected schema: z.ZodType<T>;\n\n  constructor (pathname: string, schema: z.ZodType<T>) {\n    this.http = HttpClient.getInstance();\n    this.pathname = pathname;\n    this.schema = schema;\n  }\n\n  private validateData(data: unknown[]): T[] {\n    return data.map((item) => {\n      const result = this.schema.safeParse(item);\n      if (!result.success) {\n        console.error(\"Type validation failed:\", result.error.errors);\n        throw new Error(\n          `Type validation failed: ${JSON.stringify(result.error.errors)}`,\n        );\n      }\n      return result.data;\n    });\n  }\n\n  private searchRequest(\n    search: SearchRequest,\n    options: Partial<RequestConfig> = {},\n  ): Promise<SearchResponse<T>> {\n    return this.http.request<SearchResponse<T>>(\n      {\n        method: \"POST\",\n        url: `${this.pathname}/search`,\n        data: { search },\n      },\n      options,\n    );\n  }\n\n  public async search(\n    search: SearchRequest,\n    options: Partial<RequestConfig> = {},\n  ): Promise<Array<T>> {\n    const response = await this.searchRequest(search, options);\n    return this.validateData(response.data);\n  }\n\n  public async searchPaginate(\n    search: PaginatedSearchRequest,\n    options: Partial<RequestConfig> = {},\n  ): Promise<SearchResponse<T>> {\n    const response = await this.searchRequest(search, options);\n\n    return {\n      ...response,\n      data: this.validateData(response.data),\n    };\n  }\n\n  public getdetails(\n    options: Partial<RequestConfig> = {},\n  ): Promise<DetailsResponse> {\n    return this.http.request<DetailsResponse>(\n      {\n        method: \"GET\",\n        url: this.pathname,\n      },\n      options,\n    );\n  }\n}\n","import { z } from \"zod\";\nimport { HttpClient } from \"./HttpClient\";\nimport type { RequestConfig } from \"@/types/common\";\nimport type { IAuth } from \"@/interfaces/IAuth\";\n\n\nexport abstract class Auth<\n   UserType extends object = {},\n   CredentialsType extends object = {},\n   RegisterDataType extends object = {},\n   TokenType extends object = {}\n> implements IAuth<UserType, CredentialsType, RegisterDataType, TokenType> {\n   protected http: HttpClient;\n   protected pathname: string;\n   protected userSchema: z.ZodType<UserType>;\n   protected credentialsSchema?: z.ZodType<CredentialsType>;\n   protected registerDataSchema?: z.ZodType<RegisterDataType>;\n   protected tokenSchema?: z.ZodType<TokenType>;\n\n   constructor (\n      pathname: string,\n      schemas: {\n         user: z.ZodType<UserType>;\n         credentials?: z.ZodType<CredentialsType>;\n         registerData?: z.ZodType<RegisterDataType>;\n         tokens?: z.ZodType<TokenType>;\n      }\n   ) {\n      this.http = HttpClient.getInstance();\n      this.pathname = pathname;\n      this.userSchema = schemas.user;\n      this.credentialsSchema = schemas.credentials;\n      this.registerDataSchema = schemas.registerData;\n      this.tokenSchema = schemas.tokens;\n   }\n\n   /**\n    * Inscription\n    */\n   public async register(\n      userData: RegisterDataType,\n      options: Partial<RequestConfig> = {}\n   ): Promise<UserType> {\n      // Validation des données d'inscription si un schéma est défini\n      if (this.registerDataSchema) {\n         this.registerDataSchema.parse(userData);\n      }\n\n      try {\n         const response = await this.http.request<{\n            user: UserType;\n            tokens: TokenType;\n         }>({\n            method: 'POST',\n            url: `${this.pathname}/register`,\n            data: userData\n         }, options);\n\n         // Validation du schéma de réponse\n         const user = this.userSchema.parse(response.user);\n         if (this.tokenSchema) {\n            this.tokenSchema.parse(response.tokens);\n         }\n\n         return user;\n      } catch (error) {\n         console.error('Registration error', error);\n         throw error;\n      }\n   }\n\n   /**\n    * Connexion\n    */\n   public async login(\n      credentials: CredentialsType,\n      options: Partial<RequestConfig> = {}\n   ): Promise<{\n      user: UserType;\n      tokens: TokenType;\n   }> {\n      // Validation des credentials si un schéma est défini\n      if (this.credentialsSchema) {\n         this.credentialsSchema.parse(credentials);\n      }\n\n      try {\n         const response = await this.http.request<{\n            user: UserType;\n            tokens: TokenType;\n         }>({\n            method: 'POST',\n            url: `${this.pathname}/login`,\n            data: credentials\n         }, options);\n\n         // Validation des schémas\n         const user = this.userSchema.parse(response.user);\n         const tokens = this.tokenSchema ? this.tokenSchema.parse(response.tokens) : response.tokens;\n\n         return { user, tokens };\n      } catch (error) {\n         console.error('Login error', error);\n         throw error;\n      }\n   }\n\n   /**\n    * Déconnexion\n    */\n   public async logout(\n      options: Partial<RequestConfig> = {}\n   ): Promise<void> {\n      try {\n         await this.http.request({\n            method: 'POST',\n            url: `${this.pathname}/logout`\n         }, options);\n      } catch (error) {\n         console.error('Logout error', error);\n         throw error;\n      }\n   }\n\n   /**\n    * Rafraîchissement du token\n    */\n   public async refreshToken(\n      refreshToken: string,\n      options: Partial<RequestConfig> = {}\n   ): Promise<TokenType> {\n      try {\n         const response = await this.http.request<TokenType>({\n            method: 'POST',\n            url: `${this.pathname}/refresh-token`,\n            data: { refreshToken }\n         }, options);\n\n         // Validation du schéma des tokens si défini\n         return this.tokenSchema ? this.tokenSchema.parse(response) : response;\n      } catch (error) {\n         console.error('Token refresh error', error);\n         throw error;\n      }\n   }\n\n   /**\n    * Récupération de l'utilisateur courant\n    */\n   public async getCurrentUser(\n      options: Partial<RequestConfig> = {}\n   ): Promise<UserType> {\n      try {\n         const response = await this.http.request<UserType>({\n            method: 'GET',\n            url: `${this.pathname}/me`\n         }, options);\n\n         // Validation du schéma de l'utilisateur\n         return this.userSchema.parse(response);\n      } catch (error) {\n         console.error('Get current user error', error);\n         throw error;\n      }\n   }\n};"],"names":["ApiRequestError","error","requestConfig","message","__publicField","errorObj","response","_HttpClient","config","_a","_b","httpConfig","instanceName","instance","name","options","baseUrl","prefix","errorDetails","interceptedConfig","interceptor","interceptedResponse","interceptedError","e","status","method","url","attempt","timeout","params","data","fetchOptions","fullUrl","queryParams","key","value","controller","timeoutId","body","delay","resolve","mergedConfig","apiError","HttpClient","_Builder","fn","attributes","normalAttributes","relations","operation","attrKey","nestedRelations","relationDefinition","pivot","withoutDetaching","result","Builder","Mutation","pathname","schema","item","mutateRequest","actionRequest","request","Query","search","Auth","schemas","userData","user","credentials","tokens","refreshToken"],"mappings":"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"}